{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to bosonic","text":"<p>We present <code>bosonic</code> as a framework with which to simulate quantum circuits built using bosonic quantum-error-correctable code qubits, such as the Gottesman, Kitaev and Preskill (GKP) code. As such, we build <code>bosonic</code> ontop of <code>JAX</code> to enable the auto differentiable and accelerated unitary and hamiltonian simulation of these quantum circuits with experimentally realisitic noise and dissipation.</p> <p>More docs are comming soon!</p>"},{"location":"getting_started/docs.html","title":"Docs","text":""},{"location":"getting_started/docs.html#build-and-view-locally","title":"Build and view locally","text":"<p>To view documentation locally, plesae make sure the install the requirements under the <code>docs</code> extra, as specified above. Then, run the following:</p> <pre><code>mkdocs serve\n</code></pre> <p>The documentation should now be at the url provided by the above command. </p>"},{"location":"getting_started/docs.html#updating-docs","title":"Updating Docs","text":"<p>The documentation should be updated automatically when any changes are made to the <code>main</code> branch. However, updates can also be forced by running:</p> <pre><code>mkdocs gh-deploy --force\n</code></pre> <p>This will build your documentation and deploy it to a branch gh-pages in your repository.</p>"},{"location":"getting_started/installation.html","title":"Installation","text":""},{"location":"getting_started/installation.html#installation","title":"Installation","text":"<p>Conda users, please make sure to <code>conda install pip</code> before running any pip installation if you want to install <code>bosonic</code> into your conda environment.</p>"},{"location":"getting_started/installation.html#install-from-pypi","title":"Install from PyPI","text":"<p><code>bosonic</code> will soon be published on PyPI. So, to install, simply run:</p> <pre><code>pip install bosonic\n</code></pre> <p>To check if the installation was successful, run:</p> <pre><code>python3\n&gt;&gt;&gt; import bosonic as bcj\n</code></pre> <p>If pip installation doesn't work, please build from source, as detailed below. </p>"},{"location":"getting_started/installation.html#build-from-source","title":"Build from source","text":"<p>To build <code>bosonic</code> from source, pip install using:</p> <pre><code>git clone git@github.com:Phionx/bosonic.git\ncd bosonic\npip install --upgrade .\n</code></pre> <p>If you also want to download the dependencies needed to run optional tutorials, please use <code>pip install --upgrade .[dev,docs]</code> or <code>pip install --upgrade '.[dev,docs]'</code> (for <code>zsh</code> users).</p> <p>Please Note: For now, you will also have to manually install the <code>bosonic</code> dependency, to learn how to do so please visit: https://github.com/EQuS/bosonic.</p>"},{"location":"getting_started/installation.html#installation-for-devs","title":"Installation for Devs","text":"<p>If you intend to contribute to this project, please install <code>bosonic</code> in develop mode as follows:</p> <pre><code>git clone git@github.com:Phionx/bosonic.git\ncd bosonic\npip install -e .[dev,docs]\n</code></pre> <p>Please use <code>pip install -e '.[dev,docs]'</code> if you are a <code>zsh</code> user.</p> <p>Installing the package in the usual non-editable mode would require a developer to upgrade their pip installation (i.e. run <code>pip install --upgrade .</code>) every time they update the package source code.</p> <p>Please Note: For now, you will also have to manually install the <code>bosonic</code> dependency, to learn how to do so please visit: https://github.com/EQuS/bosonic.</p>"},{"location":"reference/summary.html","title":"Summary","text":"<ul> <li>bosonic<ul> <li>circuit<ul> <li>base</li> <li>gates<ul> <li>cavity</li> <li>cavity_cavity</li> <li>cavity_qubit</li> <li>qubit</li> </ul> </li> </ul> </li> <li>codes<ul> <li>base</li> <li>binomial</li> <li>cat</li> <li>gkp</li> <li>mode</li> <li>qubit</li> </ul> </li> <li>simulator<ul> <li>base</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bosonic/index.html","title":"bosonic","text":"<p>Bosonic Codes</p>"},{"location":"reference/bosonic/index.html#bosonic.BinomialQubit","title":"<code>BinomialQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>Cat Qubit Class.</p> Source code in <code>bosonic/codes/binomial.py</code> <pre><code>class BinomialQubit(BosonicQubit):\n    \"\"\"\n    Cat Qubit Class.\n    \"\"\"\n    name = \"binomial\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n        # notation https://arxiv.org/pdf/2010.08699.pdf\n        if \"L\" not in self.params:\n            self.params[\"L\"] = 1\n        if \"G\" not in self.params:\n            self.params[\"G\"] = 0\n        if \"D\" not in self.params:\n            self.params[\"D\"] = 0\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = self.params[\"N\"]\n\n        L = self.params[\"L\"]\n        G = self.params[\"G\"]\n        D = self.params[\"D\"]\n\n        S = L + G\n\n        M = jnp.max(jnp.array([L, G, 2 * D]))\n\n        def plus_z_gen(p):\n            C = comb(M + 1, p)\n            return jnp.sqrt(C) * jqt.basis(N, p * (S + 1)).data\n\n        plus_z = jnp.sum(vmap(plus_z_gen)(jnp.arange(0, M + 2, 2)), axis=0)\n        plus_z = jqt.unit(jqt.Qarray.create(plus_z))\n\n        def minus_z_gen(p):\n            C = comb(M + 1, p)\n            return jnp.sqrt(C) * jqt.basis(N, p * (S + 1)).data\n\n        minus_z = jnp.sum(vmap(minus_z_gen)(jnp.arange(1, M + 2, 2)), axis=0)\n        minus_z = jqt.unit(jqt.Qarray.create(minus_z))\n\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicCircuit","title":"<code>BosonicCircuit</code>","text":"<p>BosonicCircuit allows users to build quantum circuits out of many bosonic qubits.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicCircuit:\n    \"\"\"\n    BosonicCircuit allows users to build quantum circuits out of many bosonic qubits.\n    \"\"\"\n\n    def __init__(self, breg: BosonicRegister):\n        self.breg = breg\n        self.reset_gates()\n\n    def get_dims(self):\n        dims = []\n        for bq in self.breg.bqubits:\n            dims.append(bq.params[\"N\"])\n        dims = jnp.array(dims)\n        dims = jnp.array([dims, jnp.ones_like(dims)])\n        return dims\n\n    @property\n    def dims(self):\n        return self.get_dims()\n\n    @property\n    def dm_dims(self):\n        return jnp.array([self.dims[0], self.dims[0]])\n\n    @property\n    def default_initial_state(self):\n        return self.gen_default_initial_state()\n\n    def gen_default_initial_state(self) -&gt; jqt.Qarray:\n        state = None\n\n        for bq in self.breg.bqubits:\n            state = (\n                bq.basis[\"+z\"] if state is None else jqt.tensor(state, bq.basis[\"+z\"])\n            )\n\n        return cast(jqt.Qarray, state)\n\n    def reset_gates(self) -&gt; None:\n        self.gates: List[BosonicGate] = []\n\n    def reset(self) -&gt; None:\n        self.reset_gates()\n\n    def add(\n        self,\n        gate_type: Type[\"BosonicGate\"],\n        bqubit_indxs: Union[int, Tuple[int, ...]],\n        params: Optional[Dict[str, complex]] = None,\n        ts: Optional[Array] = None,\n        use_unitary: Optional[bool] = False,\n    ):\n        if type(bqubit_indxs) == int:\n            bqubit_indxs = (bqubit_indxs,)\n        bqubit_indxs = cast(Tuple[int, ...], bqubit_indxs)\n\n        num_qubits = len(self.breg)\n        for j in bqubit_indxs:\n            if j &gt;= num_qubits:\n                raise ValueError(\n                    f\"Please choose qubit indices in the range [0,{num_qubits-1}]\"\n                )\n\n        self.gates.append(\n            gate_type(self, bqubit_indxs, params=params, ts=ts, use_unitary=use_unitary)\n        )\n\n    def x(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical X\n        \"\"\"\n        self.gates.append(XGate(self, bqubit_indx))\n\n    def y(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Y\n        \"\"\"\n        self.gates.append(YGate(self, bqubit_indx))\n\n    def z(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Z\n        \"\"\"\n        self.gates.append(ZGate(self, bqubit_indx))\n\n    def h(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Hadamard\n        \"\"\"\n        self.gates.append(HGate(self, bqubit_indx))\n\n    def draw(self):\n        NotImplementedError(\"Not implemented yet!\")\n\n    def jqt2qt(self, state: jqt.Qarray):\n        return jqt.jqt2qt(state)\n\n    def plot(\n        self,\n        bqubit_indx: Optional[int] = None,\n        state: Optional[jqt.Qarray] = None,\n    ):\n        \"\"\"\n        Plot default_initial_state or other state of the bcirc.\n\n        Args:\n            bqubit_indx (int): index of logical qubit in bcirc\n\n        \"\"\"\n        state = state if state is not None else self.default_initial_state\n        state = self.jqt2qt(state)\n\n        if bqubit_indx is not None:\n            self.breg[bqubit_indx].plot(state.ptrace(bqubit_indx))  # type: ignore\n        else:\n            for j in range(len(self.breg)):\n                self.breg[j].plot(state.ptrace(j))  # type: ignore\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicCircuit.h","title":"<code>h(bqubit_indx)</code>","text":"<p>Logical Hadamard</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def h(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Hadamard\n    \"\"\"\n    self.gates.append(HGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicCircuit.plot","title":"<code>plot(bqubit_indx=None, state=None)</code>","text":"<p>Plot default_initial_state or other state of the bcirc.</p> <p>Parameters:</p> Name Type Description Default <code>bqubit_indx</code> <code>int</code> <p>index of logical qubit in bcirc</p> <code>None</code> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def plot(\n    self,\n    bqubit_indx: Optional[int] = None,\n    state: Optional[jqt.Qarray] = None,\n):\n    \"\"\"\n    Plot default_initial_state or other state of the bcirc.\n\n    Args:\n        bqubit_indx (int): index of logical qubit in bcirc\n\n    \"\"\"\n    state = state if state is not None else self.default_initial_state\n    state = self.jqt2qt(state)\n\n    if bqubit_indx is not None:\n        self.breg[bqubit_indx].plot(state.ptrace(bqubit_indx))  # type: ignore\n    else:\n        for j in range(len(self.breg)):\n            self.breg[j].plot(state.ptrace(j))  # type: ignore\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicCircuit.x","title":"<code>x(bqubit_indx)</code>","text":"<p>Logical X</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def x(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical X\n    \"\"\"\n    self.gates.append(XGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicCircuit.y","title":"<code>y(bqubit_indx)</code>","text":"<p>Logical Y</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def y(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Y\n    \"\"\"\n    self.gates.append(YGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicCircuit.z","title":"<code>z(bqubit_indx)</code>","text":"<p>Logical Z</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def z(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Z\n    \"\"\"\n    self.gates.append(ZGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicGate","title":"<code>BosonicGate</code>","text":"Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicGate(metaclass=ABCMeta):\n    def __init__(\n        self,\n        bcirc: BosonicCircuit,\n        bqubit_indxs: Union[int, Tuple[int, ...]],\n        params: Optional[Dict[str, Any]] = None,\n        ts: Optional[Array] = None,\n        use_unitary: Optional[bool] = False,\n    ):\n        if type(bqubit_indxs) == int:\n            bqubit_indxs = (bqubit_indxs,)\n        bqubit_indxs = cast(Tuple[int, ...], bqubit_indxs)\n\n        self.ts = device_put(ts) if ts is not None else jnp.linspace(0, 1.0, 101)\n        self.params = params if params is not None else {}\n        self.params = device_put_params(self.params)\n\n        self.args: Dict[str, complex] = {}  # used for cython qutip mesolve\n        self.bcirc = bcirc\n        self.bqubit_indxs = bqubit_indxs\n        self.use_unitary = use_unitary\n\n        # pre-load gates\n        # self.H\n        # self.U\n\n    def __str__(self) -&gt; str:\n        return self.label\n\n    @abstractmethod\n    def get_H_func(self, t: float) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        H(t), should be overriden as needed\n\n        Args:\n            t (float): time\n\n        Returns:\n            jqt.Qarray\n        \"\"\"\n\n    @property\n    def H_func(self):\n        \"\"\"\n        Wrapper around get_H_func function.\n        \"\"\"\n        if self.use_unitary:\n            return None\n        return self.get_H_func\n\n    @property\n    def H(self):\n        \"\"\"\n        Allows the storage of H calculations. If use_unitary, then we forgo Hamiltonian simulation.\n\n        Returns:\n            H (list): first element is always a jqt.Qarray or 0\n            other elements are lists of the form [jqt.Qarray, str]\n            E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n            [0, [sigmax, \"cos(t)\"]]\n            [sigmaz]\n            [0]\n        \"\"\"\n        if self.use_unitary:\n            return None\n\n        return self.get_H()\n\n    @property\n    def H_qt(self):\n        if self.use_unitary:\n            return None\n\n        H = self.H\n        if H is None:\n            return None\n        H_qt = [\n            0 if isinstance(H[0], Number) and H[0] == 0 else self.bcirc.jqt2qt(H[0])\n        ]\n        for i in range(1, len(H)):\n            H_qt.append([self.bcirc.jqt2qt(H[i][0]), H[i][1]])\n        return H_qt\n\n    @property\n    def U(self):\n        \"\"\"\n        Allows the storage of U calculations.\n        \"\"\"\n        return self.get_U()\n\n    @property\n    def U_qt(self):\n        return self.bcirc.jqt2qt(self.U)\n\n    @property\n    @abstractmethod\n    def label(self) -&gt; str:\n        \"\"\"\n        Label of gate, used for drawing circuit.\n        E.g. \"X\"\n        \"\"\"\n\n    @abstractmethod\n    def get_H(self) -&gt; Optional[List]:\n        \"\"\"QuTiP cython-backend compatible Hamiltonian list.\n\n        Returns:\n            List of hamiltonians, used for simulation.\n                E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n        \"\"\"\n\n    def _get_U_from_H(self) -&gt; Optional[jqt.Qarray]:\n        H = self.H\n        if type(H) is list and len(H) == 1:\n            H0 = H[0]\n            if isinstance(H0, jqt.Qarray):\n                return jqt.expm(1.0j * H0)\n        return None\n\n    def get_U(self) -&gt; jqt.Qarray:\n        U = self._get_U_from_H()\n        if U is not None:\n            return U\n        raise NotImplementedError(\"Unitary gate has not been implemented.\")\n\n    def extend_gate(self, Ms: List[jqt.Qarray]):\n        \"\"\"\n        This can be used to extend a unitary gate or a hamiltonian.\n        \"\"\"\n        assert len(Ms) == len(self.bqubit_indxs), ValueError(\n            \"The number of qubit indices does not match those expected by this gate.\"\n        )\n        Ms_dict = {}\n        for i, M in enumerate(Ms):\n            Ms_dict[self.bqubit_indxs[i]] = M\n        M_tot = extend_op_to_circ(Ms_dict, self.bcirc)\n        return M_tot\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicGate.H","title":"<code>H</code>  <code>property</code>","text":"<p>Allows the storage of H calculations. If use_unitary, then we forgo Hamiltonian simulation.</p> <p>Returns:</p> Name Type Description <code>H</code> <code>list</code> <p>first element is always a jqt.Qarray or 0</p> <p>other elements are lists of the form [jqt.Qarray, str]</p> <p>E.g. [sigmaz, [sigmax, \"cos(t)\"]]</p> <p>[0, [sigmax, \"cos(t)\"]]</p> <p>[sigmaz]</p> <p>[0]</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicGate.H_func","title":"<code>H_func</code>  <code>property</code>","text":"<p>Wrapper around get_H_func function.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicGate.U","title":"<code>U</code>  <code>property</code>","text":"<p>Allows the storage of U calculations.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicGate.label","title":"<code>label: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Label of gate, used for drawing circuit. E.g. \"X\"</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicGate.extend_gate","title":"<code>extend_gate(Ms)</code>","text":"<p>This can be used to extend a unitary gate or a hamiltonian.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def extend_gate(self, Ms: List[jqt.Qarray]):\n    \"\"\"\n    This can be used to extend a unitary gate or a hamiltonian.\n    \"\"\"\n    assert len(Ms) == len(self.bqubit_indxs), ValueError(\n        \"The number of qubit indices does not match those expected by this gate.\"\n    )\n    Ms_dict = {}\n    for i, M in enumerate(Ms):\n        Ms_dict[self.bqubit_indxs[i]] = M\n    M_tot = extend_op_to_circ(Ms_dict, self.bcirc)\n    return M_tot\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicGate.get_H","title":"<code>get_H()</code>  <code>abstractmethod</code>","text":"<p>QuTiP cython-backend compatible Hamiltonian list.</p> <p>Returns:</p> Type Description <code>Optional[List]</code> <p>List of hamiltonians, used for simulation. E.g. [sigmaz, [sigmax, \"cos(t)\"]]</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>@abstractmethod\ndef get_H(self) -&gt; Optional[List]:\n    \"\"\"QuTiP cython-backend compatible Hamiltonian list.\n\n    Returns:\n        List of hamiltonians, used for simulation.\n            E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n    \"\"\"\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicGate.get_H_func","title":"<code>get_H_func(t)</code>  <code>abstractmethod</code>","text":"<p>H(t), should be overriden as needed</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time</p> required <p>Returns:</p> Type Description <code>Optional[Qarray]</code> <p>jqt.Qarray</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>@abstractmethod\ndef get_H_func(self, t: float) -&gt; Optional[jqt.Qarray]:\n    \"\"\"\n    H(t), should be overriden as needed\n\n    Args:\n        t (float): time\n\n    Returns:\n        jqt.Qarray\n    \"\"\"\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicMode","title":"<code>BosonicMode</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>FockQubit</p> Source code in <code>bosonic/codes/mode.py</code> <pre><code>class BosonicMode(BosonicQubit):\n    \"\"\"\n    FockQubit\n    \"\"\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = int(self.params[\"N\"])\n        plus_z = jqt.basis(N, 0)\n        minus_z = jqt.basis(N, 1)\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit","title":"<code>BosonicQubit</code>","text":"<p>Base class for Bosonic Qubits.</p> Source code in <code>bosonic/codes/base.py</code> <pre><code>class BosonicQubit(metaclass=ABCMeta):\n    \"\"\"\n    Base class for Bosonic Qubits.\n    \"\"\"\n    name = \"bqubit\"\n\n    @property\n    def _non_device_params(self):\n        \"\"\"\n        Can be overriden in child classes.\n        \"\"\"\n        return [\"N\"]\n\n    def __init__(self, params: Optional[Dict[str, float]] = None, name: str = None):\n        if name is not None:\n            self.name = name\n\n        self.params = params if params else {}\n        self._params_validation()\n\n        self.params = device_put_params(self.params, self._non_device_params)\n\n        self.common_gates: Dict[str, jqt.Qarray] = {}\n        self._gen_common_gates()\n\n        self.wigner_pts = jnp.linspace(-4.5, 4.5, 61)\n\n        self.basis = self._get_basis_states()\n\n        for basis_state in [\"+x\", \"-x\", \"+y\", \"-y\", \"+z\", \"-z\"]:\n            assert (\n                basis_state in self.basis\n            ), f\"Please set the {basis_state} basis state.\"\n\n    def _params_validation(self):\n        \"\"\"\n        Override this method to add additional validation to params.\n\n        E.g.\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n        \"\"\"\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n\n    def _gen_common_gates(self):\n        \"\"\"\n        Override this method to add additional common gates.\n\n        E.g.\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n        \"\"\"\n        N = self.params[\"N\"]\n        self.common_gates[\"a_dag\"] = jqt.create(N)\n        self.common_gates[\"a\"] = jqt.destroy(N)\n\n    @abstractmethod\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Returns:\n            plus_z (jqt.Qarray), minus_z (jqt.Qarray): z basis states\n        \"\"\"\n\n    def _get_basis_states(self) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        plus_z, minus_z = self._get_basis_z()\n        return self._gen_basis_states_from_z(plus_z, minus_z)\n\n    def _gen_basis_states_from_z(\n        self, plus_z: jqt.Qarray, minus_z: jqt.Qarray\n    ) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt; from |+-z&gt;\n        \"\"\"\n        basis: Dict[str, jqt.Qarray] = {}\n        N = self.params[\"N\"]\n\n        # import to make sure that each basis state is a column vec\n        # otherwise, transposing a 1D vector will do nothing\n\n        basis[\"+z\"] = plus_z\n        basis[\"-z\"] = minus_z\n\n        basis[\"+x\"] = jqt.unit(basis[\"+z\"] + basis[\"-z\"])\n        basis[\"-x\"] = jqt.unit(basis[\"+z\"] - basis[\"-z\"])\n        basis[\"+y\"] = jqt.unit(basis[\"+z\"] + 1j * basis[\"-z\"])\n        basis[\"-y\"] = jqt.unit(basis[\"+z\"] - 1j * basis[\"-z\"])\n        return basis\n\n    def jqt2qt(self, state):\n        return jqt.jqt2qt(state)\n\n    # gates\n    # ======================================================\n    # @abstractmethod\n    # def stabilize(self) -&gt; None:\n    #     \"\"\"\n    #     Stabilizing/measuring syndromes.\n    #     \"\"\"\n\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical X unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"x\")\n\n    @property\n    def x_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical X hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Y unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"y\")\n\n    @property\n    def y_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Y hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Z unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"z\")\n\n    @property\n    def z_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Z hamiltonian.\n        \"\"\"\n        return None\n\n\n    @property \n    def h_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Hadamard hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def h_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Hadamard unitary gate.\n        \"\"\"\n        return self.basis[\"+x\"] @ self.basis[\"+z\"].dag() + self.basis[\"-x\"] @ self.basis[\"-z\"].dag()\n\n    def _gen_pauli_U(self, basis_state: str) -&gt; jqt.Qarray:\n        \"\"\"\n        Generates unitary for Pauli X, Y, Z.\n\n        Args:\n            basis_state (str): \"x\", \"y\", \"z\"\n\n        Returns:\n            U (jqt.Qarray): Pauli unitary\n        \"\"\"\n        H = getattr(self, basis_state + \"_H\")\n        if H is not None:\n            return jqt.expm(1.0j * H)\n\n        gate = (\n            self.basis[\"+\" + basis_state] @ self.basis[\"+\" + basis_state].dag()\n            - self.basis[\"-\" + basis_state] @ self.basis[\"-\" + basis_state].dag()\n        )\n\n        return gate\n\n    @property\n    def projector(self):\n        return (\n            self.basis[\"+z\"] @ self.basis[\"+z\"].dag()\n            + self.basis[\"-z\"] @ self.basis[\"-z\"].dag()\n        )\n\n    @property\n    def maximally_mixed_state(self):\n        return (1 / 2.0) * self.projector()\n\n    # Plotting\n    # ======================================================\n    def _prepare_state_plot(self, state):\n        \"\"\"\n        Can be overriden.\n\n        E.g. in the case of cavity x transmon system\n        return qt.ptrace(state, 0)\n        \"\"\"\n        return state\n\n    def plot(self, state, ax=None, qp_type=jqt.WIGNER, **kwargs) -&gt; None:\n        if ax is None:\n            fig, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n        fig = ax.get_figure()\n\n        if qp_type == jqt.WIGNER:\n            vmin = -1\n            vmax = 1\n        elif qp_type == jqt.QFUNC:\n            vmin = 0\n            vmax = 1\n\n        w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n\n        ax.set_title(qp_type.capitalize() + \" Quasi-Probability Dist.\")\n        ticks = np.linspace(vmin, vmax, 5)\n        fig.colorbar(w_plt, ax=ax, ticks=ticks)\n        ax.set_xlabel(r\"Re$(\\alpha)$\")\n        ax.set_ylabel(r\"Im$(\\alpha)$\")\n        fig.tight_layout()\n\n        plt.show()\n\n    def _plot_single(self, state, ax=None, contour=True, qp_type=jqt.WIGNER):\n        \"\"\"\n        Assumes state has same dims as initial_state.\n        \"\"\"\n        state = self.jqt2qt(state)\n\n        if ax is None:\n            _, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n\n        return jqt.plot_qp(\n            state, self.wigner_pts, ax=ax, contour=contour, qp_type=qp_type\n        )\n\n    def plot_code_states(self, qp_type: str = jqt.WIGNER, **kwargs):\n        \"\"\"\n        Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.\n\n        Args:\n            qp_type (str): \n                WIGNER or QFUNC\n\n        Return:\n            axs: Axes \n        \"\"\"\n        fig, axs = plt.subplots(2, 3, figsize=(9, 6), dpi=200)\n        if qp_type == jqt.WIGNER:\n            cbar_title = r\"$\\frac{\\pi}{2} W(\\alpha)$\"\n            vmin = -1\n            vmax = 1\n        elif qp_type == jqt.QFUNC:\n            cbar_title = r\"$\\pi Q(\\alpha)$\"\n            vmin = 0\n            vmax = 1\n\n        for i, label in enumerate([\"+z\", \"+x\", \"+y\", \"-z\", \"-x\", \"-y\"]):\n            state = self._prepare_state_plot(self.basis[label])\n            pos = (i // 3, i % 3)\n            ax = axs[pos]\n            w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n            ax.set_title(f\"|{label}\" + r\"$\\rangle$\")\n            ax.set_xlabel(r\"Re[$\\alpha$]\")\n            ax.set_ylabel(r\"Im[$\\alpha$]\")\n\n        fig.suptitle(self.name)\n        fig.tight_layout()\n        fig.subplots_adjust(right=0.8, hspace=0.2, wspace=0.2)\n        fig.align_xlabels(axs)\n        fig.align_ylabels(axs)\n        cbar_ax = fig.add_axes([0.85 + 0.2, 0.15, 0.05, 0.7])\n\n        ticks = np.linspace(vmin, vmax, 5)\n        fig.colorbar(w_plt, cax=cbar_ax, ticks=ticks)\n\n        cbar_ax.set_title(cbar_title, pad=20)\n        fig.tight_layout()\n        plt.show()\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.h_H","title":"<code>h_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Hadamard hamiltonian.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.h_U","title":"<code>h_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Hadamard unitary gate.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.x_H","title":"<code>x_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical X hamiltonian.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.x_U","title":"<code>x_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical X unitary gate.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.y_H","title":"<code>y_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Y hamiltonian.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.y_U","title":"<code>y_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Y unitary gate.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.z_H","title":"<code>z_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Z hamiltonian.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.z_U","title":"<code>z_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Z unitary gate.</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicQubit.plot_code_states","title":"<code>plot_code_states(qp_type=jqt.WIGNER, **kwargs)</code>","text":"<p>Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.</p> <p>Parameters:</p> Name Type Description Default <code>qp_type</code> <code>str</code> <p>WIGNER or QFUNC</p> <code>WIGNER</code> Return <p>axs: Axes</p> Source code in <code>bosonic/codes/base.py</code> <pre><code>def plot_code_states(self, qp_type: str = jqt.WIGNER, **kwargs):\n    \"\"\"\n    Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.\n\n    Args:\n        qp_type (str): \n            WIGNER or QFUNC\n\n    Return:\n        axs: Axes \n    \"\"\"\n    fig, axs = plt.subplots(2, 3, figsize=(9, 6), dpi=200)\n    if qp_type == jqt.WIGNER:\n        cbar_title = r\"$\\frac{\\pi}{2} W(\\alpha)$\"\n        vmin = -1\n        vmax = 1\n    elif qp_type == jqt.QFUNC:\n        cbar_title = r\"$\\pi Q(\\alpha)$\"\n        vmin = 0\n        vmax = 1\n\n    for i, label in enumerate([\"+z\", \"+x\", \"+y\", \"-z\", \"-x\", \"-y\"]):\n        state = self._prepare_state_plot(self.basis[label])\n        pos = (i // 3, i % 3)\n        ax = axs[pos]\n        w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n        ax.set_title(f\"|{label}\" + r\"$\\rangle$\")\n        ax.set_xlabel(r\"Re[$\\alpha$]\")\n        ax.set_ylabel(r\"Im[$\\alpha$]\")\n\n    fig.suptitle(self.name)\n    fig.tight_layout()\n    fig.subplots_adjust(right=0.8, hspace=0.2, wspace=0.2)\n    fig.align_xlabels(axs)\n    fig.align_ylabels(axs)\n    cbar_ax = fig.add_axes([0.85 + 0.2, 0.15, 0.05, 0.7])\n\n    ticks = np.linspace(vmin, vmax, 5)\n    fig.colorbar(w_plt, cax=cbar_ax, ticks=ticks)\n\n    cbar_ax.set_title(cbar_title, pad=20)\n    fig.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicRegister","title":"<code>BosonicRegister</code>","text":"<p>Register of bosonic qubits.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicRegister:\n    \"\"\"\n    Register of bosonic qubits.\n    \"\"\"\n\n    def __init__(\n        self,\n        bqubits: List[BosonicQubit],\n    ):\n        \"\"\"\n        Bosonic Register Init Method\n\n        Args:\n            bqubits:\n                List of bosonic qubits to store in BosonicRegister\n        \"\"\"\n        self.bqubits: List[BosonicQubit] = bqubits\n\n    def __getitem__(self, key: int):\n        \"\"\"\n        Allows us to return the nth element of BosonicRegister as a list.\n        \"\"\"\n        return self.bqubits[key]\n\n    def __len__(self):\n        return len(self.bqubits)\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicRegister.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allows us to return the nth element of BosonicRegister as a list.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def __getitem__(self, key: int):\n    \"\"\"\n    Allows us to return the nth element of BosonicRegister as a list.\n    \"\"\"\n    return self.bqubits[key]\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicRegister.__init__","title":"<code>__init__(bqubits)</code>","text":"<p>Bosonic Register Init Method</p> <p>Parameters:</p> Name Type Description Default <code>bqubits</code> <code>List[BosonicQubit]</code> <p>List of bosonic qubits to store in BosonicRegister</p> required Source code in <code>bosonic/circuit/base.py</code> <pre><code>def __init__(\n    self,\n    bqubits: List[BosonicQubit],\n):\n    \"\"\"\n    Bosonic Register Init Method\n\n    Args:\n        bqubits:\n            List of bosonic qubits to store in BosonicRegister\n    \"\"\"\n    self.bqubits: List[BosonicQubit] = bqubits\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicResults","title":"<code>BosonicResults</code>","text":"<p>BosonicResults class to hold results of simulation.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>class BosonicResults:\n    \"\"\"\n    BosonicResults class to hold results of simulation.\n    \"\"\"\n\n    def __init__(self, results: Optional[List] = None):\n        self.__results = results if results is not None else []\n\n    @property\n    def results(self):\n        \"\"\"\n        self.results is read-only\n        \"\"\"\n        return self.__results\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return str(self.results)\n\n    def __getitem__(self, j: int):\n        return self.results[j]\n\n    def calc_expect(self, op: jqt.Qarray, op_name: str):\n        \"\"\"\n        TODO (if needed):\n        This only works for jax simulations.\n        We may want to extend it to accomodate QuTiP mesolve sims.\n        \"\"\"\n\n        def calc_exp_state(state: Array):\n            return (jnp.conj(state).T @ op.data @ state)[0][0]\n\n        for i in range(len(self.results)):\n            if op_name not in self.results[i]:\n                self.results[i][op_name] = vmap(calc_exp_state)(\n                    jqt.jqts2jnps(self.results[i][\"states\"])\n                )\n\n    def append(self, states):\n        self.__results.append({\"states\": states})\n\n    def plot(self, bcirc: BosonicCircuit, indx: Optional[int] = None):\n        \"\"\"\n        Plots final state.\n        \"\"\"\n        bcirc.plot(indx, state=self.results[-1][\"states\"][-1])\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicResults.results","title":"<code>results</code>  <code>property</code>","text":"<p>self.results is read-only</p>"},{"location":"reference/bosonic/index.html#bosonic.BosonicResults.calc_expect","title":"<code>calc_expect(op, op_name)</code>","text":"<p>TODO (if needed): This only works for jax simulations. We may want to extend it to accomodate QuTiP mesolve sims.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>def calc_expect(self, op: jqt.Qarray, op_name: str):\n    \"\"\"\n    TODO (if needed):\n    This only works for jax simulations.\n    We may want to extend it to accomodate QuTiP mesolve sims.\n    \"\"\"\n\n    def calc_exp_state(state: Array):\n        return (jnp.conj(state).T @ op.data @ state)[0][0]\n\n    for i in range(len(self.results)):\n        if op_name not in self.results[i]:\n            self.results[i][op_name] = vmap(calc_exp_state)(\n                jqt.jqts2jnps(self.results[i][\"states\"])\n            )\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.BosonicResults.plot","title":"<code>plot(bcirc, indx=None)</code>","text":"<p>Plots final state.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>def plot(self, bcirc: BosonicCircuit, indx: Optional[int] = None):\n    \"\"\"\n    Plots final state.\n    \"\"\"\n    bcirc.plot(indx, state=self.results[-1][\"states\"][-1])\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.CDGate","title":"<code>CDGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going from t=0 to t=1 to get correct \u03b2.</p>"},{"location":"reference/bosonic/index.html#bosonic.CDGate--todo-maybe-add-rate-scale-factor-g-so-that-t-runs-from-0-to-1g","title":"TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g","text":"Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>class CDGate(BosonicGate):\n    \"\"\"\n    Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going\n    from t=0 to t=1 to get correct \u03b2.\n    # TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g\n    \"\"\"\n\n    label = \"CD\"\n\n    def get_H(self) -&gt; List:\n\n        N = self.bcirc.breg[self.bqubit_indxs[0]].params[\"N\"]\n        N2 = self.bcirc.breg[self.bqubit_indxs[1]].params[\"N\"]\n        assert N2 == 2, ValueError(\n            \"Please use a two level system for your second qubit.\"\n        )\n        beta = self.params[\"beta\"]\n        a = jqt.destroy(N)\n        H_tot = self.extend_gate(\n            [\n                1.0j * (beta * jqt.dag(a) - jnp.conj(beta) * a) / jnp.sqrt(2),\n                jqt.sigmaz() / 2,\n            ]\n        )\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        N = self.bcirc.breg[self.bqubit_indxs[0]].params[\"N\"]\n        N2 = self.bcirc.breg[self.bqubit_indxs[1]].params[\"N\"]\n        assert N2 == 2, ValueError(\n            \"Please use a two level system for your second qubit.\"\n        )\n        beta = self.params[\"beta\"]\n        a = jqt.destroy(N)\n        Hs = [\n            -1.0j * (beta * jqt.dag(a) - jnp.conj(beta) * a) / jnp.sqrt(2),\n            jqt.sigmaz() / 2,\n        ]\n        H_tot = self.extend_gate(Hs)\n        U_tot = jqt.expm(1.0j * H_tot)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.CatQubit","title":"<code>CatQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>Cat Qubit Class.</p> Source code in <code>bosonic/codes/cat.py</code> <pre><code>class CatQubit(BosonicQubit):\n    \"\"\"\n    Cat Qubit Class.\n    \"\"\"\n    name = \"cat\"\n\n    @property\n    def _non_device_params(self):\n        param_list = super()._non_device_params\n        param_list.append(\"alpha\")\n        return param_list\n\n    def _params_validation(self):\n        super()._params_validation()\n        if \"alpha\" not in self.params:\n            self.params[\"alpha\"] = 2\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = self.params[\"N\"]\n        a = self.params[\"alpha\"]\n        plus_z = jqt.unit(jqt.coherent(N, a) + jqt.coherent(N, -1.0 * a))\n        minus_z = jqt.unit(jqt.coherent(N, 1.0j * a) + jqt.coherent(N, -1.0j * a))\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.GKPCHGate","title":"<code>GKPCHGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going from t=0 to t=1 to get correct \u03b2.</p>"},{"location":"reference/bosonic/index.html#bosonic.GKPCHGate--todo-maybe-add-rate-scale-factor-g-so-that-t-runs-from-0-to-1g","title":"TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g","text":"Source code in <code>bosonic/circuit/gates/cavity_cavity.py</code> <pre><code>class GKPCHGate(BosonicGate):\n    \"\"\"\n    Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going\n    from t=0 to t=1 to get correct \u03b2.\n    # TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g\n    \"\"\"\n\n    label = \"GKP CH\"\n\n    def get_H(self) -&gt; List:\n\n        q0 = self.bcirc.breg[self.bqubit_indxs[0]]\n        q1 = self.bcirc.breg[self.bqubit_indxs[1]]\n\n        a = q0.common_gates[\"a\"]\n        a_dag = q0.common_gates[\"a_dag\"]\n\n        b = q1.common_gates[\"a\"]\n        b_dag = q1.common_gates[\"a_dag\"]\n\n        chi = self.params[\"chi\"]\n\n        H_tot = self.extend_gate(\n            [\n                chi * (a_dag + a),\n                (b_dag @ b),\n            ]\n        )\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        q0 = self.bcirc.breg[self.bqubit_indxs[0]]\n        q1 = self.bcirc.breg[self.bqubit_indxs[1]]\n\n        a = q0.common_gates[\"a\"]\n        a_dag = q0.common_gates[\"a_dag\"]\n\n        b = q1.common_gates[\"a\"]\n        b_dag = q1.common_gates[\"a_dag\"]\n\n        angle = jnp.pi/2\n\n        H_tot = self.extend_gate(\n            [\n                angle * (a_dag + a),\n                (b_dag @ b),\n            ]\n        )\n\n        U_tot = jqt.expm(1.0j * H_tot)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.GKPQubit","title":"<code>GKPQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>GKP Qubit Class.</p> Source code in <code>bosonic/codes/gkp.py</code> <pre><code>class GKPQubit(BosonicQubit):\n    \"\"\"\n    GKP Qubit Class.\n    \"\"\"\n    name = \"gkp\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n        if \"delta\" not in self.params:\n            self.params[\"delta\"] = 0.25\n        self.params[\"l\"] = 2.0 * jnp.sqrt(jnp.pi)\n        s_delta = jnp.sinh(self.params[\"delta\"] ** 2)\n        self.params[\"epsilon\"] = s_delta * self.params[\"l\"]\n\n    def _gen_common_gates(self) -&gt; None:\n        \"\"\"\n        Overriding this method to add additional common gates.\n        \"\"\"\n        super()._gen_common_gates()\n\n        # phase space\n        self.common_gates[\"x\"] = (\n            self.common_gates[\"a_dag\"] + self.common_gates[\"a\"]\n        ) / jnp.sqrt(2.0)\n        self.common_gates[\"p\"] = (\n            1.0j * (self.common_gates[\"a_dag\"] - self.common_gates[\"a\"]) / jnp.sqrt(2.0)\n        )\n\n        # finite energy\n        self.common_gates[\"E\"] = jqt.expm(\n            -self.params[\"delta\"] ** 2\n            * self.common_gates[\"a_dag\"]\n            @ self.common_gates[\"a\"]\n        )\n        self.common_gates[\"E_inv\"] = jqt.expm(\n            self.params[\"delta\"] ** 2\n            * self.common_gates[\"a_dag\"]\n            @ self.common_gates[\"a\"]\n        )\n\n        # axis\n        x_axis, z_axis = self._get_axis()\n        y_axis = x_axis + z_axis\n\n        # gates\n        X_0 = jqt.expm(1.0j * self.params[\"l\"] / 2.0 * z_axis)\n        Z_0 = jqt.expm(1.0j * self.params[\"l\"] / 2.0 * x_axis)\n        Y_0 = 1.0j * X_0 @ Z_0\n        self.common_gates[\"X\"] = self._make_op_finite_energy(X_0)\n        self.common_gates[\"Z\"] = self._make_op_finite_energy(Z_0)\n        self.common_gates[\"Y\"] = self._make_op_finite_energy(Y_0)\n\n        # symmetric stabilizers and gates\n        self.common_gates[\"Z_s_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] / 2.0 * x_axis\n        )\n        self.common_gates[\"S_x_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * z_axis\n        )\n        self.common_gates[\"S_z_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * x_axis\n        )\n        self.common_gates[\"S_y_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * y_axis\n        )\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;.\n        step 1: use ideal GKP stabilizers to find ideal GKP |+z&gt; state\n        step 2: make ideal eigenvector finite energy\n            We want the groundstate of H = E H_0 E\u207b\u00b9.\n            So, we can begin by find the groundstate of H_0 -&gt; |\u03bb\u2080\u27e9\n            Then, we know that E|\u03bb\u2080\u27e9 = |\u03bb\u27e9 is the groundstate of H.\n            pf. H|\u03bb\u27e9 = (E H_0 E\u207b\u00b9)(E|\u03bb\u2080\u27e9) = E H_0 |\u03bb\u2080\u27e9 = \u03bb\u2080 (E|\u03bb\u2080\u27e9) = \u03bb\u2080|\u03bb\u27e9\n\n        TODO (if necessary):\n            Alternatively, we could construct a hamiltonian using\n            finite energy stabilizers S_x, S_y, S_z, Z_s. However,\n            this would make H = - S_x - S_y - S_z - Z_s non-hermitian.\n            Currently, JAX does not support derivatives of jnp.linalg.eig,\n            while it does support derivatives of jnp.linalg.eigh.\n            Discussion: https://github.com/google/jax/issues/2748\n        \"\"\"\n\n        # step 1: use ideal GKP stabilizers to find ideal GKP |+z&gt; state\n        H_0 = (\n            -self.common_gates[\"S_x_0\"]\n            - self.common_gates[\"S_y_0\"]\n            - self.common_gates[\"S_z_0\"]\n            - self.common_gates[\"Z_s_0\"]  # bosonic |+z&gt; state\n        )\n\n        _, vecs = jnp.linalg.eigh(H_0.data)\n        gstate_ideal = jqt.Qarray.create(vecs[:, 0])\n\n        # step 2: make ideal eigenvector finite energy\n        gstate = self.common_gates[\"E\"] @ gstate_ideal\n\n        N = self.params[\"N\"]\n        plus_z = jqt.unit(gstate)\n        minus_z = self.common_gates[\"X\"] @ plus_z\n        return plus_z, minus_z\n\n    # utils\n    # ======================================================\n    def _get_axis(self):\n        x_axis = self.common_gates[\"x\"]\n        z_axis = -self.common_gates[\"p\"]\n        return x_axis, z_axis\n\n    def _make_op_finite_energy(self, op):\n        return self.common_gates[\"E\"] @ op @ self.common_gates[\"E_inv\"]\n\n    def _symmetrized_expm(self, op):\n        return (jqt.expm(op) + jqt.expm(-1.0 * op)) / 2.0\n\n    # gates\n    # ======================================================\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"X\"]\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"Y\"]\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"Z\"]\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.HGate","title":"<code>HGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>HGate.</p> Source code in <code>bosonic/circuit/gates/qubit.py</code> <pre><code>class HGate(BosonicGate):\n    \"\"\"HGate.\"\"\"\n\n    label = \"H\"\n\n    def get_H(self) -&gt; Optional[List]:\n        # TODO: implement this\n        return [0]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        raise NotImplementedError(\"No Hamiltonian for HGate.\")\n\n    def get_U(self) -&gt; jqt.Qarray:\n        Us = [jqt.hadamard()]\n        U_tot = self.extend_gate(Us)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.Qubit","title":"<code>Qubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>FockQubit</p> Source code in <code>bosonic/codes/qubit.py</code> <pre><code>class Qubit(BosonicQubit):\n    \"\"\"\n    FockQubit\n    \"\"\"\n\n    def _params_validation(self):\n        super()._params_validation()\n        self.params[\"N\"] = 2\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = int(self.params[\"N\"])\n        plus_z = jqt.basis(N, 0)\n        minus_z = jqt.basis(N, 1)\n        return plus_z, minus_z\n\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmax()\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmay()\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmaz()\n\n    def plot(self, state, ax=None, qp_type=\"\", **kwargs) -&gt; None:\n        state = self.jqt2qt(state)\n        with warnings.catch_warnings():\n            # TODO: suppressing deprecation warnings, deal with this\n            warnings.simplefilter(\"ignore\")\n            b = qt.Bloch()\n            b.add_states(state)\n            b.render()\n            b.show()\n            plt.tight_layout()\n            plt.show()\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.QubitRotationGate","title":"<code>QubitRotationGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Qubit Rotation Gate R_a(\u03b8) about an axis a = [ax, ay, az] of the Bloch spheres. If no axis is provided, defaults to to R_x(\u03b8) about x-axis.</p> Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>class QubitRotationGate(BosonicGate):\n    \"\"\"\n    Qubit Rotation Gate R_a(\u03b8) about an axis a = [ax, ay, az] of the Bloch\n    spheres. If no axis is provided, defaults to to R_x(\u03b8) about x-axis.\n    \"\"\"\n\n    label = \"Qubit Rotation\"\n\n    def get_sigma_tot(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Helper function that returns (a\u2022\u03c3) = ax*\u03c3x + ay*\u03c3y + az*\u03c3z given\n        an input Bloch vector a. If none is provided, default to \u03c3x.\n        \"\"\"\n\n        if \"rot_axis\" in self.params.keys():\n            a = jnp.array(self.params[\"rot_axis\"])\n            norm = jnp.linalg.norm(a)\n\n            # if a.size != 3 or norm == 0.0:\n            #     raise ValueError(\n            #         \"Please use a nonzero Bloch vector of the form a = [ax, ay, az] \u2260 [0,0,0].\"\n            #     )\n\n            a = (1 / norm) * a\n            sigma_tot = a[0] * jqt.sigmax() + a[1] * jqt.sigmay() + a[2] * jqt.sigmaz()\n\n        else:\n            sigma_tot = jqt.sigmax()\n\n        return sigma_tot\n\n    def get_H(self) -&gt; List:\n\n        omega = self.params[\"omega\"]\n        sigma_tot = self.get_sigma_tot()\n\n        H_tot = self.extend_gate([sigma_tot * omega / 2])\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        theta = self.params[\"theta\"]\n        sigma_tot = self.get_sigma_tot()\n\n        H_tot = self.extend_gate([sigma_tot * theta / 2])\n\n        return jqt.expm(-1.0j * H_tot)\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.QubitRotationGate.get_sigma_tot","title":"<code>get_sigma_tot()</code>","text":"<p>Helper function that returns (a\u2022\u03c3) = ax\u03c3x + ay\u03c3y + az*\u03c3z given an input Bloch vector a. If none is provided, default to \u03c3x.</p> Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>def get_sigma_tot(self) -&gt; jqt.Qarray:\n    \"\"\"\n    Helper function that returns (a\u2022\u03c3) = ax*\u03c3x + ay*\u03c3y + az*\u03c3z given\n    an input Bloch vector a. If none is provided, default to \u03c3x.\n    \"\"\"\n\n    if \"rot_axis\" in self.params.keys():\n        a = jnp.array(self.params[\"rot_axis\"])\n        norm = jnp.linalg.norm(a)\n\n        # if a.size != 3 or norm == 0.0:\n        #     raise ValueError(\n        #         \"Please use a nonzero Bloch vector of the form a = [ax, ay, az] \u2260 [0,0,0].\"\n        #     )\n\n        a = (1 / norm) * a\n        sigma_tot = a[0] * jqt.sigmax() + a[1] * jqt.sigmay() + a[2] * jqt.sigmaz()\n\n    else:\n        sigma_tot = jqt.sigmax()\n\n    return sigma_tot\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.extend_op_to_circ","title":"<code>extend_op_to_circ(Ms, bcirc)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>Ms</code> <code>dict</code> <p>key: qubit index in bcirc value: operator corresponding to qubit examples:     {0:Qobj1, 2:Qobj2}</p> required <code>bcirc</code> <code>BosonicCircuit</code> <p>bosonic quantum circuit</p> required <p>Returns:</p> Name Type Description <code>M_tot</code> <code>Qarray</code> <p>tensored operator that can act on state space of entire circuit</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def extend_op_to_circ(Ms: Dict[int, jqt.Qarray], bcirc: BosonicCircuit):\n    \"\"\"\n    Arguments:\n        Ms (dict):\n            key: qubit index in bcirc\n            value: operator corresponding to qubit\n            examples:\n                {0:Qobj1, 2:Qobj2}\n        bcirc (BosonicCircuit):\n            bosonic quantum circuit\n\n    Returns:\n        M_tot (jqt.Qarray):\n            tensored operator that can act on state space of entire circuit\n    \"\"\"\n    M_tot = None\n    n = len(bcirc.breg.bqubits)\n    for q_indx in range(n):\n        M = Ms.get(q_indx, jqt.identity(bcirc.breg[q_indx].params[\"N\"]))\n        M_tot = M if M_tot is None else jqt.tensor(M_tot, M)\n    return M_tot\n</code></pre>"},{"location":"reference/bosonic/index.html#bosonic.hamiltonian_jax_simulate","title":"<code>hamiltonian_jax_simulate(bcirc, H0, p0=None, default_unitary=True, c_ops=None, results_in=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>H0</code> <code>Qarray</code> <p>base system hamiltonian, please make sure this a jnp.array not a QuTiP Qobj</p> required Source code in <code>bosonic/simulator/base.py</code> <pre><code>def hamiltonian_jax_simulate(\n    bcirc: BosonicCircuit,\n    H0: jqt.Qarray,\n    p0: jqt.Qarray = None,\n    default_unitary=True,\n    c_ops=None,\n    results_in: Optional[BosonicResults] = None,\n):\n    \"\"\"\n\n    Args:\n        H0 (jqt.Qarray):\n            base system hamiltonian,\n            please make sure this a jnp.array not a QuTiP Qobj\n    \"\"\"\n    # p0 is a density matrix, but can also be wavefunction if c_ops=None\n    p = p0 if p0 is not None else bcirc.default_initial_state\n    c_ops = c_ops if c_ops is not None else []\n\n    p = jqt.qt2jqt(p)\n\n    if len(c_ops) &gt; 0 and not p.is_dm():\n        # if simulating with noise and p is a vector,\n        # then turn p into a density matrix\n        p = p.to_dm()\n\n    use_density_matrix = p.is_dm()\n    results = BosonicResults() if results_in is None else results_in\n\n    results.append([p])\n\n    for gate in bcirc.gates:\n        t_list = gate.ts\n        use_hamiltonian = not (gate.H_func is None or gate.H_func(t_list[0]) is None)\n\n        if use_hamiltonian:\n            states = hamiltonian_jax_step(\n                gate.H_func,\n                p,\n                t_list,\n                H0,\n                c_ops=c_ops,\n                use_density_matrix=use_density_matrix,\n            )\n            results.append(states)\n            p = states[-1]\n        elif default_unitary:\n            # H_func is None or returns None, then just use unitary evolution\n            U = jqt.qt2jqt(gate.U)\n            p = unitary_jax_step(p, U, use_density_matrix=use_density_matrix)\n            results.append([p])\n        else:\n            warnings.warn(f\"{gate} Gate was skipped.\", RuntimeWarning, stacklevel=2)\n\n    return results\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html","title":"circuit","text":"<p>Bosonic Circuit and Gates Classes</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicCircuit","title":"<code>BosonicCircuit</code>","text":"<p>BosonicCircuit allows users to build quantum circuits out of many bosonic qubits.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicCircuit:\n    \"\"\"\n    BosonicCircuit allows users to build quantum circuits out of many bosonic qubits.\n    \"\"\"\n\n    def __init__(self, breg: BosonicRegister):\n        self.breg = breg\n        self.reset_gates()\n\n    def get_dims(self):\n        dims = []\n        for bq in self.breg.bqubits:\n            dims.append(bq.params[\"N\"])\n        dims = jnp.array(dims)\n        dims = jnp.array([dims, jnp.ones_like(dims)])\n        return dims\n\n    @property\n    def dims(self):\n        return self.get_dims()\n\n    @property\n    def dm_dims(self):\n        return jnp.array([self.dims[0], self.dims[0]])\n\n    @property\n    def default_initial_state(self):\n        return self.gen_default_initial_state()\n\n    def gen_default_initial_state(self) -&gt; jqt.Qarray:\n        state = None\n\n        for bq in self.breg.bqubits:\n            state = (\n                bq.basis[\"+z\"] if state is None else jqt.tensor(state, bq.basis[\"+z\"])\n            )\n\n        return cast(jqt.Qarray, state)\n\n    def reset_gates(self) -&gt; None:\n        self.gates: List[BosonicGate] = []\n\n    def reset(self) -&gt; None:\n        self.reset_gates()\n\n    def add(\n        self,\n        gate_type: Type[\"BosonicGate\"],\n        bqubit_indxs: Union[int, Tuple[int, ...]],\n        params: Optional[Dict[str, complex]] = None,\n        ts: Optional[Array] = None,\n        use_unitary: Optional[bool] = False,\n    ):\n        if type(bqubit_indxs) == int:\n            bqubit_indxs = (bqubit_indxs,)\n        bqubit_indxs = cast(Tuple[int, ...], bqubit_indxs)\n\n        num_qubits = len(self.breg)\n        for j in bqubit_indxs:\n            if j &gt;= num_qubits:\n                raise ValueError(\n                    f\"Please choose qubit indices in the range [0,{num_qubits-1}]\"\n                )\n\n        self.gates.append(\n            gate_type(self, bqubit_indxs, params=params, ts=ts, use_unitary=use_unitary)\n        )\n\n    def x(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical X\n        \"\"\"\n        self.gates.append(XGate(self, bqubit_indx))\n\n    def y(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Y\n        \"\"\"\n        self.gates.append(YGate(self, bqubit_indx))\n\n    def z(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Z\n        \"\"\"\n        self.gates.append(ZGate(self, bqubit_indx))\n\n    def h(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Hadamard\n        \"\"\"\n        self.gates.append(HGate(self, bqubit_indx))\n\n    def draw(self):\n        NotImplementedError(\"Not implemented yet!\")\n\n    def jqt2qt(self, state: jqt.Qarray):\n        return jqt.jqt2qt(state)\n\n    def plot(\n        self,\n        bqubit_indx: Optional[int] = None,\n        state: Optional[jqt.Qarray] = None,\n    ):\n        \"\"\"\n        Plot default_initial_state or other state of the bcirc.\n\n        Args:\n            bqubit_indx (int): index of logical qubit in bcirc\n\n        \"\"\"\n        state = state if state is not None else self.default_initial_state\n        state = self.jqt2qt(state)\n\n        if bqubit_indx is not None:\n            self.breg[bqubit_indx].plot(state.ptrace(bqubit_indx))  # type: ignore\n        else:\n            for j in range(len(self.breg)):\n                self.breg[j].plot(state.ptrace(j))  # type: ignore\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicCircuit.h","title":"<code>h(bqubit_indx)</code>","text":"<p>Logical Hadamard</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def h(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Hadamard\n    \"\"\"\n    self.gates.append(HGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicCircuit.plot","title":"<code>plot(bqubit_indx=None, state=None)</code>","text":"<p>Plot default_initial_state or other state of the bcirc.</p> <p>Parameters:</p> Name Type Description Default <code>bqubit_indx</code> <code>int</code> <p>index of logical qubit in bcirc</p> <code>None</code> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def plot(\n    self,\n    bqubit_indx: Optional[int] = None,\n    state: Optional[jqt.Qarray] = None,\n):\n    \"\"\"\n    Plot default_initial_state or other state of the bcirc.\n\n    Args:\n        bqubit_indx (int): index of logical qubit in bcirc\n\n    \"\"\"\n    state = state if state is not None else self.default_initial_state\n    state = self.jqt2qt(state)\n\n    if bqubit_indx is not None:\n        self.breg[bqubit_indx].plot(state.ptrace(bqubit_indx))  # type: ignore\n    else:\n        for j in range(len(self.breg)):\n            self.breg[j].plot(state.ptrace(j))  # type: ignore\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicCircuit.x","title":"<code>x(bqubit_indx)</code>","text":"<p>Logical X</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def x(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical X\n    \"\"\"\n    self.gates.append(XGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicCircuit.y","title":"<code>y(bqubit_indx)</code>","text":"<p>Logical Y</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def y(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Y\n    \"\"\"\n    self.gates.append(YGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicCircuit.z","title":"<code>z(bqubit_indx)</code>","text":"<p>Logical Z</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def z(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Z\n    \"\"\"\n    self.gates.append(ZGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicGate","title":"<code>BosonicGate</code>","text":"Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicGate(metaclass=ABCMeta):\n    def __init__(\n        self,\n        bcirc: BosonicCircuit,\n        bqubit_indxs: Union[int, Tuple[int, ...]],\n        params: Optional[Dict[str, Any]] = None,\n        ts: Optional[Array] = None,\n        use_unitary: Optional[bool] = False,\n    ):\n        if type(bqubit_indxs) == int:\n            bqubit_indxs = (bqubit_indxs,)\n        bqubit_indxs = cast(Tuple[int, ...], bqubit_indxs)\n\n        self.ts = device_put(ts) if ts is not None else jnp.linspace(0, 1.0, 101)\n        self.params = params if params is not None else {}\n        self.params = device_put_params(self.params)\n\n        self.args: Dict[str, complex] = {}  # used for cython qutip mesolve\n        self.bcirc = bcirc\n        self.bqubit_indxs = bqubit_indxs\n        self.use_unitary = use_unitary\n\n        # pre-load gates\n        # self.H\n        # self.U\n\n    def __str__(self) -&gt; str:\n        return self.label\n\n    @abstractmethod\n    def get_H_func(self, t: float) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        H(t), should be overriden as needed\n\n        Args:\n            t (float): time\n\n        Returns:\n            jqt.Qarray\n        \"\"\"\n\n    @property\n    def H_func(self):\n        \"\"\"\n        Wrapper around get_H_func function.\n        \"\"\"\n        if self.use_unitary:\n            return None\n        return self.get_H_func\n\n    @property\n    def H(self):\n        \"\"\"\n        Allows the storage of H calculations. If use_unitary, then we forgo Hamiltonian simulation.\n\n        Returns:\n            H (list): first element is always a jqt.Qarray or 0\n            other elements are lists of the form [jqt.Qarray, str]\n            E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n            [0, [sigmax, \"cos(t)\"]]\n            [sigmaz]\n            [0]\n        \"\"\"\n        if self.use_unitary:\n            return None\n\n        return self.get_H()\n\n    @property\n    def H_qt(self):\n        if self.use_unitary:\n            return None\n\n        H = self.H\n        if H is None:\n            return None\n        H_qt = [\n            0 if isinstance(H[0], Number) and H[0] == 0 else self.bcirc.jqt2qt(H[0])\n        ]\n        for i in range(1, len(H)):\n            H_qt.append([self.bcirc.jqt2qt(H[i][0]), H[i][1]])\n        return H_qt\n\n    @property\n    def U(self):\n        \"\"\"\n        Allows the storage of U calculations.\n        \"\"\"\n        return self.get_U()\n\n    @property\n    def U_qt(self):\n        return self.bcirc.jqt2qt(self.U)\n\n    @property\n    @abstractmethod\n    def label(self) -&gt; str:\n        \"\"\"\n        Label of gate, used for drawing circuit.\n        E.g. \"X\"\n        \"\"\"\n\n    @abstractmethod\n    def get_H(self) -&gt; Optional[List]:\n        \"\"\"QuTiP cython-backend compatible Hamiltonian list.\n\n        Returns:\n            List of hamiltonians, used for simulation.\n                E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n        \"\"\"\n\n    def _get_U_from_H(self) -&gt; Optional[jqt.Qarray]:\n        H = self.H\n        if type(H) is list and len(H) == 1:\n            H0 = H[0]\n            if isinstance(H0, jqt.Qarray):\n                return jqt.expm(1.0j * H0)\n        return None\n\n    def get_U(self) -&gt; jqt.Qarray:\n        U = self._get_U_from_H()\n        if U is not None:\n            return U\n        raise NotImplementedError(\"Unitary gate has not been implemented.\")\n\n    def extend_gate(self, Ms: List[jqt.Qarray]):\n        \"\"\"\n        This can be used to extend a unitary gate or a hamiltonian.\n        \"\"\"\n        assert len(Ms) == len(self.bqubit_indxs), ValueError(\n            \"The number of qubit indices does not match those expected by this gate.\"\n        )\n        Ms_dict = {}\n        for i, M in enumerate(Ms):\n            Ms_dict[self.bqubit_indxs[i]] = M\n        M_tot = extend_op_to_circ(Ms_dict, self.bcirc)\n        return M_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicGate.H","title":"<code>H</code>  <code>property</code>","text":"<p>Allows the storage of H calculations. If use_unitary, then we forgo Hamiltonian simulation.</p> <p>Returns:</p> Name Type Description <code>H</code> <code>list</code> <p>first element is always a jqt.Qarray or 0</p> <p>other elements are lists of the form [jqt.Qarray, str]</p> <p>E.g. [sigmaz, [sigmax, \"cos(t)\"]]</p> <p>[0, [sigmax, \"cos(t)\"]]</p> <p>[sigmaz]</p> <p>[0]</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicGate.H_func","title":"<code>H_func</code>  <code>property</code>","text":"<p>Wrapper around get_H_func function.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicGate.U","title":"<code>U</code>  <code>property</code>","text":"<p>Allows the storage of U calculations.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicGate.label","title":"<code>label: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Label of gate, used for drawing circuit. E.g. \"X\"</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicGate.extend_gate","title":"<code>extend_gate(Ms)</code>","text":"<p>This can be used to extend a unitary gate or a hamiltonian.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def extend_gate(self, Ms: List[jqt.Qarray]):\n    \"\"\"\n    This can be used to extend a unitary gate or a hamiltonian.\n    \"\"\"\n    assert len(Ms) == len(self.bqubit_indxs), ValueError(\n        \"The number of qubit indices does not match those expected by this gate.\"\n    )\n    Ms_dict = {}\n    for i, M in enumerate(Ms):\n        Ms_dict[self.bqubit_indxs[i]] = M\n    M_tot = extend_op_to_circ(Ms_dict, self.bcirc)\n    return M_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicGate.get_H","title":"<code>get_H()</code>  <code>abstractmethod</code>","text":"<p>QuTiP cython-backend compatible Hamiltonian list.</p> <p>Returns:</p> Type Description <code>Optional[List]</code> <p>List of hamiltonians, used for simulation. E.g. [sigmaz, [sigmax, \"cos(t)\"]]</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>@abstractmethod\ndef get_H(self) -&gt; Optional[List]:\n    \"\"\"QuTiP cython-backend compatible Hamiltonian list.\n\n    Returns:\n        List of hamiltonians, used for simulation.\n            E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n    \"\"\"\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicGate.get_H_func","title":"<code>get_H_func(t)</code>  <code>abstractmethod</code>","text":"<p>H(t), should be overriden as needed</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time</p> required <p>Returns:</p> Type Description <code>Optional[Qarray]</code> <p>jqt.Qarray</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>@abstractmethod\ndef get_H_func(self, t: float) -&gt; Optional[jqt.Qarray]:\n    \"\"\"\n    H(t), should be overriden as needed\n\n    Args:\n        t (float): time\n\n    Returns:\n        jqt.Qarray\n    \"\"\"\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit","title":"<code>BosonicQubit</code>","text":"<p>Base class for Bosonic Qubits.</p> Source code in <code>bosonic/codes/base.py</code> <pre><code>class BosonicQubit(metaclass=ABCMeta):\n    \"\"\"\n    Base class for Bosonic Qubits.\n    \"\"\"\n    name = \"bqubit\"\n\n    @property\n    def _non_device_params(self):\n        \"\"\"\n        Can be overriden in child classes.\n        \"\"\"\n        return [\"N\"]\n\n    def __init__(self, params: Optional[Dict[str, float]] = None, name: str = None):\n        if name is not None:\n            self.name = name\n\n        self.params = params if params else {}\n        self._params_validation()\n\n        self.params = device_put_params(self.params, self._non_device_params)\n\n        self.common_gates: Dict[str, jqt.Qarray] = {}\n        self._gen_common_gates()\n\n        self.wigner_pts = jnp.linspace(-4.5, 4.5, 61)\n\n        self.basis = self._get_basis_states()\n\n        for basis_state in [\"+x\", \"-x\", \"+y\", \"-y\", \"+z\", \"-z\"]:\n            assert (\n                basis_state in self.basis\n            ), f\"Please set the {basis_state} basis state.\"\n\n    def _params_validation(self):\n        \"\"\"\n        Override this method to add additional validation to params.\n\n        E.g.\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n        \"\"\"\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n\n    def _gen_common_gates(self):\n        \"\"\"\n        Override this method to add additional common gates.\n\n        E.g.\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n        \"\"\"\n        N = self.params[\"N\"]\n        self.common_gates[\"a_dag\"] = jqt.create(N)\n        self.common_gates[\"a\"] = jqt.destroy(N)\n\n    @abstractmethod\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Returns:\n            plus_z (jqt.Qarray), minus_z (jqt.Qarray): z basis states\n        \"\"\"\n\n    def _get_basis_states(self) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        plus_z, minus_z = self._get_basis_z()\n        return self._gen_basis_states_from_z(plus_z, minus_z)\n\n    def _gen_basis_states_from_z(\n        self, plus_z: jqt.Qarray, minus_z: jqt.Qarray\n    ) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt; from |+-z&gt;\n        \"\"\"\n        basis: Dict[str, jqt.Qarray] = {}\n        N = self.params[\"N\"]\n\n        # import to make sure that each basis state is a column vec\n        # otherwise, transposing a 1D vector will do nothing\n\n        basis[\"+z\"] = plus_z\n        basis[\"-z\"] = minus_z\n\n        basis[\"+x\"] = jqt.unit(basis[\"+z\"] + basis[\"-z\"])\n        basis[\"-x\"] = jqt.unit(basis[\"+z\"] - basis[\"-z\"])\n        basis[\"+y\"] = jqt.unit(basis[\"+z\"] + 1j * basis[\"-z\"])\n        basis[\"-y\"] = jqt.unit(basis[\"+z\"] - 1j * basis[\"-z\"])\n        return basis\n\n    def jqt2qt(self, state):\n        return jqt.jqt2qt(state)\n\n    # gates\n    # ======================================================\n    # @abstractmethod\n    # def stabilize(self) -&gt; None:\n    #     \"\"\"\n    #     Stabilizing/measuring syndromes.\n    #     \"\"\"\n\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical X unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"x\")\n\n    @property\n    def x_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical X hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Y unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"y\")\n\n    @property\n    def y_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Y hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Z unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"z\")\n\n    @property\n    def z_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Z hamiltonian.\n        \"\"\"\n        return None\n\n\n    @property \n    def h_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Hadamard hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def h_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Hadamard unitary gate.\n        \"\"\"\n        return self.basis[\"+x\"] @ self.basis[\"+z\"].dag() + self.basis[\"-x\"] @ self.basis[\"-z\"].dag()\n\n    def _gen_pauli_U(self, basis_state: str) -&gt; jqt.Qarray:\n        \"\"\"\n        Generates unitary for Pauli X, Y, Z.\n\n        Args:\n            basis_state (str): \"x\", \"y\", \"z\"\n\n        Returns:\n            U (jqt.Qarray): Pauli unitary\n        \"\"\"\n        H = getattr(self, basis_state + \"_H\")\n        if H is not None:\n            return jqt.expm(1.0j * H)\n\n        gate = (\n            self.basis[\"+\" + basis_state] @ self.basis[\"+\" + basis_state].dag()\n            - self.basis[\"-\" + basis_state] @ self.basis[\"-\" + basis_state].dag()\n        )\n\n        return gate\n\n    @property\n    def projector(self):\n        return (\n            self.basis[\"+z\"] @ self.basis[\"+z\"].dag()\n            + self.basis[\"-z\"] @ self.basis[\"-z\"].dag()\n        )\n\n    @property\n    def maximally_mixed_state(self):\n        return (1 / 2.0) * self.projector()\n\n    # Plotting\n    # ======================================================\n    def _prepare_state_plot(self, state):\n        \"\"\"\n        Can be overriden.\n\n        E.g. in the case of cavity x transmon system\n        return qt.ptrace(state, 0)\n        \"\"\"\n        return state\n\n    def plot(self, state, ax=None, qp_type=jqt.WIGNER, **kwargs) -&gt; None:\n        if ax is None:\n            fig, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n        fig = ax.get_figure()\n\n        if qp_type == jqt.WIGNER:\n            vmin = -1\n            vmax = 1\n        elif qp_type == jqt.QFUNC:\n            vmin = 0\n            vmax = 1\n\n        w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n\n        ax.set_title(qp_type.capitalize() + \" Quasi-Probability Dist.\")\n        ticks = np.linspace(vmin, vmax, 5)\n        fig.colorbar(w_plt, ax=ax, ticks=ticks)\n        ax.set_xlabel(r\"Re$(\\alpha)$\")\n        ax.set_ylabel(r\"Im$(\\alpha)$\")\n        fig.tight_layout()\n\n        plt.show()\n\n    def _plot_single(self, state, ax=None, contour=True, qp_type=jqt.WIGNER):\n        \"\"\"\n        Assumes state has same dims as initial_state.\n        \"\"\"\n        state = self.jqt2qt(state)\n\n        if ax is None:\n            _, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n\n        return jqt.plot_qp(\n            state, self.wigner_pts, ax=ax, contour=contour, qp_type=qp_type\n        )\n\n    def plot_code_states(self, qp_type: str = jqt.WIGNER, **kwargs):\n        \"\"\"\n        Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.\n\n        Args:\n            qp_type (str): \n                WIGNER or QFUNC\n\n        Return:\n            axs: Axes \n        \"\"\"\n        fig, axs = plt.subplots(2, 3, figsize=(9, 6), dpi=200)\n        if qp_type == jqt.WIGNER:\n            cbar_title = r\"$\\frac{\\pi}{2} W(\\alpha)$\"\n            vmin = -1\n            vmax = 1\n        elif qp_type == jqt.QFUNC:\n            cbar_title = r\"$\\pi Q(\\alpha)$\"\n            vmin = 0\n            vmax = 1\n\n        for i, label in enumerate([\"+z\", \"+x\", \"+y\", \"-z\", \"-x\", \"-y\"]):\n            state = self._prepare_state_plot(self.basis[label])\n            pos = (i // 3, i % 3)\n            ax = axs[pos]\n            w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n            ax.set_title(f\"|{label}\" + r\"$\\rangle$\")\n            ax.set_xlabel(r\"Re[$\\alpha$]\")\n            ax.set_ylabel(r\"Im[$\\alpha$]\")\n\n        fig.suptitle(self.name)\n        fig.tight_layout()\n        fig.subplots_adjust(right=0.8, hspace=0.2, wspace=0.2)\n        fig.align_xlabels(axs)\n        fig.align_ylabels(axs)\n        cbar_ax = fig.add_axes([0.85 + 0.2, 0.15, 0.05, 0.7])\n\n        ticks = np.linspace(vmin, vmax, 5)\n        fig.colorbar(w_plt, cax=cbar_ax, ticks=ticks)\n\n        cbar_ax.set_title(cbar_title, pad=20)\n        fig.tight_layout()\n        plt.show()\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.h_H","title":"<code>h_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Hadamard hamiltonian.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.h_U","title":"<code>h_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Hadamard unitary gate.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.x_H","title":"<code>x_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical X hamiltonian.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.x_U","title":"<code>x_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical X unitary gate.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.y_H","title":"<code>y_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Y hamiltonian.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.y_U","title":"<code>y_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Y unitary gate.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.z_H","title":"<code>z_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Z hamiltonian.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.z_U","title":"<code>z_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Z unitary gate.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicQubit.plot_code_states","title":"<code>plot_code_states(qp_type=jqt.WIGNER, **kwargs)</code>","text":"<p>Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.</p> <p>Parameters:</p> Name Type Description Default <code>qp_type</code> <code>str</code> <p>WIGNER or QFUNC</p> <code>WIGNER</code> Return <p>axs: Axes</p> Source code in <code>bosonic/codes/base.py</code> <pre><code>def plot_code_states(self, qp_type: str = jqt.WIGNER, **kwargs):\n    \"\"\"\n    Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.\n\n    Args:\n        qp_type (str): \n            WIGNER or QFUNC\n\n    Return:\n        axs: Axes \n    \"\"\"\n    fig, axs = plt.subplots(2, 3, figsize=(9, 6), dpi=200)\n    if qp_type == jqt.WIGNER:\n        cbar_title = r\"$\\frac{\\pi}{2} W(\\alpha)$\"\n        vmin = -1\n        vmax = 1\n    elif qp_type == jqt.QFUNC:\n        cbar_title = r\"$\\pi Q(\\alpha)$\"\n        vmin = 0\n        vmax = 1\n\n    for i, label in enumerate([\"+z\", \"+x\", \"+y\", \"-z\", \"-x\", \"-y\"]):\n        state = self._prepare_state_plot(self.basis[label])\n        pos = (i // 3, i % 3)\n        ax = axs[pos]\n        w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n        ax.set_title(f\"|{label}\" + r\"$\\rangle$\")\n        ax.set_xlabel(r\"Re[$\\alpha$]\")\n        ax.set_ylabel(r\"Im[$\\alpha$]\")\n\n    fig.suptitle(self.name)\n    fig.tight_layout()\n    fig.subplots_adjust(right=0.8, hspace=0.2, wspace=0.2)\n    fig.align_xlabels(axs)\n    fig.align_ylabels(axs)\n    cbar_ax = fig.add_axes([0.85 + 0.2, 0.15, 0.05, 0.7])\n\n    ticks = np.linspace(vmin, vmax, 5)\n    fig.colorbar(w_plt, cax=cbar_ax, ticks=ticks)\n\n    cbar_ax.set_title(cbar_title, pad=20)\n    fig.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicRegister","title":"<code>BosonicRegister</code>","text":"<p>Register of bosonic qubits.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicRegister:\n    \"\"\"\n    Register of bosonic qubits.\n    \"\"\"\n\n    def __init__(\n        self,\n        bqubits: List[BosonicQubit],\n    ):\n        \"\"\"\n        Bosonic Register Init Method\n\n        Args:\n            bqubits:\n                List of bosonic qubits to store in BosonicRegister\n        \"\"\"\n        self.bqubits: List[BosonicQubit] = bqubits\n\n    def __getitem__(self, key: int):\n        \"\"\"\n        Allows us to return the nth element of BosonicRegister as a list.\n        \"\"\"\n        return self.bqubits[key]\n\n    def __len__(self):\n        return len(self.bqubits)\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicRegister.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allows us to return the nth element of BosonicRegister as a list.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def __getitem__(self, key: int):\n    \"\"\"\n    Allows us to return the nth element of BosonicRegister as a list.\n    \"\"\"\n    return self.bqubits[key]\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.BosonicRegister.__init__","title":"<code>__init__(bqubits)</code>","text":"<p>Bosonic Register Init Method</p> <p>Parameters:</p> Name Type Description Default <code>bqubits</code> <code>List[BosonicQubit]</code> <p>List of bosonic qubits to store in BosonicRegister</p> required Source code in <code>bosonic/circuit/base.py</code> <pre><code>def __init__(\n    self,\n    bqubits: List[BosonicQubit],\n):\n    \"\"\"\n    Bosonic Register Init Method\n\n    Args:\n        bqubits:\n            List of bosonic qubits to store in BosonicRegister\n    \"\"\"\n    self.bqubits: List[BosonicQubit] = bqubits\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.CDGate","title":"<code>CDGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going from t=0 to t=1 to get correct \u03b2.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.CDGate--todo-maybe-add-rate-scale-factor-g-so-that-t-runs-from-0-to-1g","title":"TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g","text":"Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>class CDGate(BosonicGate):\n    \"\"\"\n    Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going\n    from t=0 to t=1 to get correct \u03b2.\n    # TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g\n    \"\"\"\n\n    label = \"CD\"\n\n    def get_H(self) -&gt; List:\n\n        N = self.bcirc.breg[self.bqubit_indxs[0]].params[\"N\"]\n        N2 = self.bcirc.breg[self.bqubit_indxs[1]].params[\"N\"]\n        assert N2 == 2, ValueError(\n            \"Please use a two level system for your second qubit.\"\n        )\n        beta = self.params[\"beta\"]\n        a = jqt.destroy(N)\n        H_tot = self.extend_gate(\n            [\n                1.0j * (beta * jqt.dag(a) - jnp.conj(beta) * a) / jnp.sqrt(2),\n                jqt.sigmaz() / 2,\n            ]\n        )\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        N = self.bcirc.breg[self.bqubit_indxs[0]].params[\"N\"]\n        N2 = self.bcirc.breg[self.bqubit_indxs[1]].params[\"N\"]\n        assert N2 == 2, ValueError(\n            \"Please use a two level system for your second qubit.\"\n        )\n        beta = self.params[\"beta\"]\n        a = jqt.destroy(N)\n        Hs = [\n            -1.0j * (beta * jqt.dag(a) - jnp.conj(beta) * a) / jnp.sqrt(2),\n            jqt.sigmaz() / 2,\n        ]\n        H_tot = self.extend_gate(Hs)\n        U_tot = jqt.expm(1.0j * H_tot)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.GKPCHGate","title":"<code>GKPCHGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going from t=0 to t=1 to get correct \u03b2.</p>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.GKPCHGate--todo-maybe-add-rate-scale-factor-g-so-that-t-runs-from-0-to-1g","title":"TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g","text":"Source code in <code>bosonic/circuit/gates/cavity_cavity.py</code> <pre><code>class GKPCHGate(BosonicGate):\n    \"\"\"\n    Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going\n    from t=0 to t=1 to get correct \u03b2.\n    # TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g\n    \"\"\"\n\n    label = \"GKP CH\"\n\n    def get_H(self) -&gt; List:\n\n        q0 = self.bcirc.breg[self.bqubit_indxs[0]]\n        q1 = self.bcirc.breg[self.bqubit_indxs[1]]\n\n        a = q0.common_gates[\"a\"]\n        a_dag = q0.common_gates[\"a_dag\"]\n\n        b = q1.common_gates[\"a\"]\n        b_dag = q1.common_gates[\"a_dag\"]\n\n        chi = self.params[\"chi\"]\n\n        H_tot = self.extend_gate(\n            [\n                chi * (a_dag + a),\n                (b_dag @ b),\n            ]\n        )\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        q0 = self.bcirc.breg[self.bqubit_indxs[0]]\n        q1 = self.bcirc.breg[self.bqubit_indxs[1]]\n\n        a = q0.common_gates[\"a\"]\n        a_dag = q0.common_gates[\"a_dag\"]\n\n        b = q1.common_gates[\"a\"]\n        b_dag = q1.common_gates[\"a_dag\"]\n\n        angle = jnp.pi/2\n\n        H_tot = self.extend_gate(\n            [\n                angle * (a_dag + a),\n                (b_dag @ b),\n            ]\n        )\n\n        U_tot = jqt.expm(1.0j * H_tot)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.HGate","title":"<code>HGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>HGate.</p> Source code in <code>bosonic/circuit/gates/qubit.py</code> <pre><code>class HGate(BosonicGate):\n    \"\"\"HGate.\"\"\"\n\n    label = \"H\"\n\n    def get_H(self) -&gt; Optional[List]:\n        # TODO: implement this\n        return [0]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        raise NotImplementedError(\"No Hamiltonian for HGate.\")\n\n    def get_U(self) -&gt; jqt.Qarray:\n        Us = [jqt.hadamard()]\n        U_tot = self.extend_gate(Us)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.QubitRotationGate","title":"<code>QubitRotationGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Qubit Rotation Gate R_a(\u03b8) about an axis a = [ax, ay, az] of the Bloch spheres. If no axis is provided, defaults to to R_x(\u03b8) about x-axis.</p> Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>class QubitRotationGate(BosonicGate):\n    \"\"\"\n    Qubit Rotation Gate R_a(\u03b8) about an axis a = [ax, ay, az] of the Bloch\n    spheres. If no axis is provided, defaults to to R_x(\u03b8) about x-axis.\n    \"\"\"\n\n    label = \"Qubit Rotation\"\n\n    def get_sigma_tot(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Helper function that returns (a\u2022\u03c3) = ax*\u03c3x + ay*\u03c3y + az*\u03c3z given\n        an input Bloch vector a. If none is provided, default to \u03c3x.\n        \"\"\"\n\n        if \"rot_axis\" in self.params.keys():\n            a = jnp.array(self.params[\"rot_axis\"])\n            norm = jnp.linalg.norm(a)\n\n            # if a.size != 3 or norm == 0.0:\n            #     raise ValueError(\n            #         \"Please use a nonzero Bloch vector of the form a = [ax, ay, az] \u2260 [0,0,0].\"\n            #     )\n\n            a = (1 / norm) * a\n            sigma_tot = a[0] * jqt.sigmax() + a[1] * jqt.sigmay() + a[2] * jqt.sigmaz()\n\n        else:\n            sigma_tot = jqt.sigmax()\n\n        return sigma_tot\n\n    def get_H(self) -&gt; List:\n\n        omega = self.params[\"omega\"]\n        sigma_tot = self.get_sigma_tot()\n\n        H_tot = self.extend_gate([sigma_tot * omega / 2])\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        theta = self.params[\"theta\"]\n        sigma_tot = self.get_sigma_tot()\n\n        H_tot = self.extend_gate([sigma_tot * theta / 2])\n\n        return jqt.expm(-1.0j * H_tot)\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.QubitRotationGate.get_sigma_tot","title":"<code>get_sigma_tot()</code>","text":"<p>Helper function that returns (a\u2022\u03c3) = ax\u03c3x + ay\u03c3y + az*\u03c3z given an input Bloch vector a. If none is provided, default to \u03c3x.</p> Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>def get_sigma_tot(self) -&gt; jqt.Qarray:\n    \"\"\"\n    Helper function that returns (a\u2022\u03c3) = ax*\u03c3x + ay*\u03c3y + az*\u03c3z given\n    an input Bloch vector a. If none is provided, default to \u03c3x.\n    \"\"\"\n\n    if \"rot_axis\" in self.params.keys():\n        a = jnp.array(self.params[\"rot_axis\"])\n        norm = jnp.linalg.norm(a)\n\n        # if a.size != 3 or norm == 0.0:\n        #     raise ValueError(\n        #         \"Please use a nonzero Bloch vector of the form a = [ax, ay, az] \u2260 [0,0,0].\"\n        #     )\n\n        a = (1 / norm) * a\n        sigma_tot = a[0] * jqt.sigmax() + a[1] * jqt.sigmay() + a[2] * jqt.sigmaz()\n\n    else:\n        sigma_tot = jqt.sigmax()\n\n    return sigma_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/index.html#bosonic.circuit.extend_op_to_circ","title":"<code>extend_op_to_circ(Ms, bcirc)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>Ms</code> <code>dict</code> <p>key: qubit index in bcirc value: operator corresponding to qubit examples:     {0:Qobj1, 2:Qobj2}</p> required <code>bcirc</code> <code>BosonicCircuit</code> <p>bosonic quantum circuit</p> required <p>Returns:</p> Name Type Description <code>M_tot</code> <code>Qarray</code> <p>tensored operator that can act on state space of entire circuit</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def extend_op_to_circ(Ms: Dict[int, jqt.Qarray], bcirc: BosonicCircuit):\n    \"\"\"\n    Arguments:\n        Ms (dict):\n            key: qubit index in bcirc\n            value: operator corresponding to qubit\n            examples:\n                {0:Qobj1, 2:Qobj2}\n        bcirc (BosonicCircuit):\n            bosonic quantum circuit\n\n    Returns:\n        M_tot (jqt.Qarray):\n            tensored operator that can act on state space of entire circuit\n    \"\"\"\n    M_tot = None\n    n = len(bcirc.breg.bqubits)\n    for q_indx in range(n):\n        M = Ms.get(q_indx, jqt.identity(bcirc.breg[q_indx].params[\"N\"]))\n        M_tot = M if M_tot is None else jqt.tensor(M_tot, M)\n    return M_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html","title":"base","text":"<p>Bosonic Quantum Circuit</p>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicCircuit","title":"<code>BosonicCircuit</code>","text":"<p>BosonicCircuit allows users to build quantum circuits out of many bosonic qubits.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicCircuit:\n    \"\"\"\n    BosonicCircuit allows users to build quantum circuits out of many bosonic qubits.\n    \"\"\"\n\n    def __init__(self, breg: BosonicRegister):\n        self.breg = breg\n        self.reset_gates()\n\n    def get_dims(self):\n        dims = []\n        for bq in self.breg.bqubits:\n            dims.append(bq.params[\"N\"])\n        dims = jnp.array(dims)\n        dims = jnp.array([dims, jnp.ones_like(dims)])\n        return dims\n\n    @property\n    def dims(self):\n        return self.get_dims()\n\n    @property\n    def dm_dims(self):\n        return jnp.array([self.dims[0], self.dims[0]])\n\n    @property\n    def default_initial_state(self):\n        return self.gen_default_initial_state()\n\n    def gen_default_initial_state(self) -&gt; jqt.Qarray:\n        state = None\n\n        for bq in self.breg.bqubits:\n            state = (\n                bq.basis[\"+z\"] if state is None else jqt.tensor(state, bq.basis[\"+z\"])\n            )\n\n        return cast(jqt.Qarray, state)\n\n    def reset_gates(self) -&gt; None:\n        self.gates: List[BosonicGate] = []\n\n    def reset(self) -&gt; None:\n        self.reset_gates()\n\n    def add(\n        self,\n        gate_type: Type[\"BosonicGate\"],\n        bqubit_indxs: Union[int, Tuple[int, ...]],\n        params: Optional[Dict[str, complex]] = None,\n        ts: Optional[Array] = None,\n        use_unitary: Optional[bool] = False,\n    ):\n        if type(bqubit_indxs) == int:\n            bqubit_indxs = (bqubit_indxs,)\n        bqubit_indxs = cast(Tuple[int, ...], bqubit_indxs)\n\n        num_qubits = len(self.breg)\n        for j in bqubit_indxs:\n            if j &gt;= num_qubits:\n                raise ValueError(\n                    f\"Please choose qubit indices in the range [0,{num_qubits-1}]\"\n                )\n\n        self.gates.append(\n            gate_type(self, bqubit_indxs, params=params, ts=ts, use_unitary=use_unitary)\n        )\n\n    def x(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical X\n        \"\"\"\n        self.gates.append(XGate(self, bqubit_indx))\n\n    def y(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Y\n        \"\"\"\n        self.gates.append(YGate(self, bqubit_indx))\n\n    def z(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Z\n        \"\"\"\n        self.gates.append(ZGate(self, bqubit_indx))\n\n    def h(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Hadamard\n        \"\"\"\n        self.gates.append(HGate(self, bqubit_indx))\n\n    def draw(self):\n        NotImplementedError(\"Not implemented yet!\")\n\n    def jqt2qt(self, state: jqt.Qarray):\n        return jqt.jqt2qt(state)\n\n    def plot(\n        self,\n        bqubit_indx: Optional[int] = None,\n        state: Optional[jqt.Qarray] = None,\n    ):\n        \"\"\"\n        Plot default_initial_state or other state of the bcirc.\n\n        Args:\n            bqubit_indx (int): index of logical qubit in bcirc\n\n        \"\"\"\n        state = state if state is not None else self.default_initial_state\n        state = self.jqt2qt(state)\n\n        if bqubit_indx is not None:\n            self.breg[bqubit_indx].plot(state.ptrace(bqubit_indx))  # type: ignore\n        else:\n            for j in range(len(self.breg)):\n                self.breg[j].plot(state.ptrace(j))  # type: ignore\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicCircuit.h","title":"<code>h(bqubit_indx)</code>","text":"<p>Logical Hadamard</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def h(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Hadamard\n    \"\"\"\n    self.gates.append(HGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicCircuit.plot","title":"<code>plot(bqubit_indx=None, state=None)</code>","text":"<p>Plot default_initial_state or other state of the bcirc.</p> <p>Parameters:</p> Name Type Description Default <code>bqubit_indx</code> <code>int</code> <p>index of logical qubit in bcirc</p> <code>None</code> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def plot(\n    self,\n    bqubit_indx: Optional[int] = None,\n    state: Optional[jqt.Qarray] = None,\n):\n    \"\"\"\n    Plot default_initial_state or other state of the bcirc.\n\n    Args:\n        bqubit_indx (int): index of logical qubit in bcirc\n\n    \"\"\"\n    state = state if state is not None else self.default_initial_state\n    state = self.jqt2qt(state)\n\n    if bqubit_indx is not None:\n        self.breg[bqubit_indx].plot(state.ptrace(bqubit_indx))  # type: ignore\n    else:\n        for j in range(len(self.breg)):\n            self.breg[j].plot(state.ptrace(j))  # type: ignore\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicCircuit.x","title":"<code>x(bqubit_indx)</code>","text":"<p>Logical X</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def x(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical X\n    \"\"\"\n    self.gates.append(XGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicCircuit.y","title":"<code>y(bqubit_indx)</code>","text":"<p>Logical Y</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def y(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Y\n    \"\"\"\n    self.gates.append(YGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicCircuit.z","title":"<code>z(bqubit_indx)</code>","text":"<p>Logical Z</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def z(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Z\n    \"\"\"\n    self.gates.append(ZGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicGate","title":"<code>BosonicGate</code>","text":"Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicGate(metaclass=ABCMeta):\n    def __init__(\n        self,\n        bcirc: BosonicCircuit,\n        bqubit_indxs: Union[int, Tuple[int, ...]],\n        params: Optional[Dict[str, Any]] = None,\n        ts: Optional[Array] = None,\n        use_unitary: Optional[bool] = False,\n    ):\n        if type(bqubit_indxs) == int:\n            bqubit_indxs = (bqubit_indxs,)\n        bqubit_indxs = cast(Tuple[int, ...], bqubit_indxs)\n\n        self.ts = device_put(ts) if ts is not None else jnp.linspace(0, 1.0, 101)\n        self.params = params if params is not None else {}\n        self.params = device_put_params(self.params)\n\n        self.args: Dict[str, complex] = {}  # used for cython qutip mesolve\n        self.bcirc = bcirc\n        self.bqubit_indxs = bqubit_indxs\n        self.use_unitary = use_unitary\n\n        # pre-load gates\n        # self.H\n        # self.U\n\n    def __str__(self) -&gt; str:\n        return self.label\n\n    @abstractmethod\n    def get_H_func(self, t: float) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        H(t), should be overriden as needed\n\n        Args:\n            t (float): time\n\n        Returns:\n            jqt.Qarray\n        \"\"\"\n\n    @property\n    def H_func(self):\n        \"\"\"\n        Wrapper around get_H_func function.\n        \"\"\"\n        if self.use_unitary:\n            return None\n        return self.get_H_func\n\n    @property\n    def H(self):\n        \"\"\"\n        Allows the storage of H calculations. If use_unitary, then we forgo Hamiltonian simulation.\n\n        Returns:\n            H (list): first element is always a jqt.Qarray or 0\n            other elements are lists of the form [jqt.Qarray, str]\n            E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n            [0, [sigmax, \"cos(t)\"]]\n            [sigmaz]\n            [0]\n        \"\"\"\n        if self.use_unitary:\n            return None\n\n        return self.get_H()\n\n    @property\n    def H_qt(self):\n        if self.use_unitary:\n            return None\n\n        H = self.H\n        if H is None:\n            return None\n        H_qt = [\n            0 if isinstance(H[0], Number) and H[0] == 0 else self.bcirc.jqt2qt(H[0])\n        ]\n        for i in range(1, len(H)):\n            H_qt.append([self.bcirc.jqt2qt(H[i][0]), H[i][1]])\n        return H_qt\n\n    @property\n    def U(self):\n        \"\"\"\n        Allows the storage of U calculations.\n        \"\"\"\n        return self.get_U()\n\n    @property\n    def U_qt(self):\n        return self.bcirc.jqt2qt(self.U)\n\n    @property\n    @abstractmethod\n    def label(self) -&gt; str:\n        \"\"\"\n        Label of gate, used for drawing circuit.\n        E.g. \"X\"\n        \"\"\"\n\n    @abstractmethod\n    def get_H(self) -&gt; Optional[List]:\n        \"\"\"QuTiP cython-backend compatible Hamiltonian list.\n\n        Returns:\n            List of hamiltonians, used for simulation.\n                E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n        \"\"\"\n\n    def _get_U_from_H(self) -&gt; Optional[jqt.Qarray]:\n        H = self.H\n        if type(H) is list and len(H) == 1:\n            H0 = H[0]\n            if isinstance(H0, jqt.Qarray):\n                return jqt.expm(1.0j * H0)\n        return None\n\n    def get_U(self) -&gt; jqt.Qarray:\n        U = self._get_U_from_H()\n        if U is not None:\n            return U\n        raise NotImplementedError(\"Unitary gate has not been implemented.\")\n\n    def extend_gate(self, Ms: List[jqt.Qarray]):\n        \"\"\"\n        This can be used to extend a unitary gate or a hamiltonian.\n        \"\"\"\n        assert len(Ms) == len(self.bqubit_indxs), ValueError(\n            \"The number of qubit indices does not match those expected by this gate.\"\n        )\n        Ms_dict = {}\n        for i, M in enumerate(Ms):\n            Ms_dict[self.bqubit_indxs[i]] = M\n        M_tot = extend_op_to_circ(Ms_dict, self.bcirc)\n        return M_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicGate.H","title":"<code>H</code>  <code>property</code>","text":"<p>Allows the storage of H calculations. If use_unitary, then we forgo Hamiltonian simulation.</p> <p>Returns:</p> Name Type Description <code>H</code> <code>list</code> <p>first element is always a jqt.Qarray or 0</p> <p>other elements are lists of the form [jqt.Qarray, str]</p> <p>E.g. [sigmaz, [sigmax, \"cos(t)\"]]</p> <p>[0, [sigmax, \"cos(t)\"]]</p> <p>[sigmaz]</p> <p>[0]</p>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicGate.H_func","title":"<code>H_func</code>  <code>property</code>","text":"<p>Wrapper around get_H_func function.</p>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicGate.U","title":"<code>U</code>  <code>property</code>","text":"<p>Allows the storage of U calculations.</p>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicGate.label","title":"<code>label: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Label of gate, used for drawing circuit. E.g. \"X\"</p>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicGate.extend_gate","title":"<code>extend_gate(Ms)</code>","text":"<p>This can be used to extend a unitary gate or a hamiltonian.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def extend_gate(self, Ms: List[jqt.Qarray]):\n    \"\"\"\n    This can be used to extend a unitary gate or a hamiltonian.\n    \"\"\"\n    assert len(Ms) == len(self.bqubit_indxs), ValueError(\n        \"The number of qubit indices does not match those expected by this gate.\"\n    )\n    Ms_dict = {}\n    for i, M in enumerate(Ms):\n        Ms_dict[self.bqubit_indxs[i]] = M\n    M_tot = extend_op_to_circ(Ms_dict, self.bcirc)\n    return M_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicGate.get_H","title":"<code>get_H()</code>  <code>abstractmethod</code>","text":"<p>QuTiP cython-backend compatible Hamiltonian list.</p> <p>Returns:</p> Type Description <code>Optional[List]</code> <p>List of hamiltonians, used for simulation. E.g. [sigmaz, [sigmax, \"cos(t)\"]]</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>@abstractmethod\ndef get_H(self) -&gt; Optional[List]:\n    \"\"\"QuTiP cython-backend compatible Hamiltonian list.\n\n    Returns:\n        List of hamiltonians, used for simulation.\n            E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n    \"\"\"\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicGate.get_H_func","title":"<code>get_H_func(t)</code>  <code>abstractmethod</code>","text":"<p>H(t), should be overriden as needed</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time</p> required <p>Returns:</p> Type Description <code>Optional[Qarray]</code> <p>jqt.Qarray</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>@abstractmethod\ndef get_H_func(self, t: float) -&gt; Optional[jqt.Qarray]:\n    \"\"\"\n    H(t), should be overriden as needed\n\n    Args:\n        t (float): time\n\n    Returns:\n        jqt.Qarray\n    \"\"\"\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicRegister","title":"<code>BosonicRegister</code>","text":"<p>Register of bosonic qubits.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicRegister:\n    \"\"\"\n    Register of bosonic qubits.\n    \"\"\"\n\n    def __init__(\n        self,\n        bqubits: List[BosonicQubit],\n    ):\n        \"\"\"\n        Bosonic Register Init Method\n\n        Args:\n            bqubits:\n                List of bosonic qubits to store in BosonicRegister\n        \"\"\"\n        self.bqubits: List[BosonicQubit] = bqubits\n\n    def __getitem__(self, key: int):\n        \"\"\"\n        Allows us to return the nth element of BosonicRegister as a list.\n        \"\"\"\n        return self.bqubits[key]\n\n    def __len__(self):\n        return len(self.bqubits)\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicRegister.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allows us to return the nth element of BosonicRegister as a list.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def __getitem__(self, key: int):\n    \"\"\"\n    Allows us to return the nth element of BosonicRegister as a list.\n    \"\"\"\n    return self.bqubits[key]\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.BosonicRegister.__init__","title":"<code>__init__(bqubits)</code>","text":"<p>Bosonic Register Init Method</p> <p>Parameters:</p> Name Type Description Default <code>bqubits</code> <code>List[BosonicQubit]</code> <p>List of bosonic qubits to store in BosonicRegister</p> required Source code in <code>bosonic/circuit/base.py</code> <pre><code>def __init__(\n    self,\n    bqubits: List[BosonicQubit],\n):\n    \"\"\"\n    Bosonic Register Init Method\n\n    Args:\n        bqubits:\n            List of bosonic qubits to store in BosonicRegister\n    \"\"\"\n    self.bqubits: List[BosonicQubit] = bqubits\n</code></pre>"},{"location":"reference/bosonic/circuit/base.html#bosonic.circuit.base.extend_op_to_circ","title":"<code>extend_op_to_circ(Ms, bcirc)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>Ms</code> <code>dict</code> <p>key: qubit index in bcirc value: operator corresponding to qubit examples:     {0:Qobj1, 2:Qobj2}</p> required <code>bcirc</code> <code>BosonicCircuit</code> <p>bosonic quantum circuit</p> required <p>Returns:</p> Name Type Description <code>M_tot</code> <code>Qarray</code> <p>tensored operator that can act on state space of entire circuit</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def extend_op_to_circ(Ms: Dict[int, jqt.Qarray], bcirc: BosonicCircuit):\n    \"\"\"\n    Arguments:\n        Ms (dict):\n            key: qubit index in bcirc\n            value: operator corresponding to qubit\n            examples:\n                {0:Qobj1, 2:Qobj2}\n        bcirc (BosonicCircuit):\n            bosonic quantum circuit\n\n    Returns:\n        M_tot (jqt.Qarray):\n            tensored operator that can act on state space of entire circuit\n    \"\"\"\n    M_tot = None\n    n = len(bcirc.breg.bqubits)\n    for q_indx in range(n):\n        M = Ms.get(q_indx, jqt.identity(bcirc.breg[q_indx].params[\"N\"]))\n        M_tot = M if M_tot is None else jqt.tensor(M_tot, M)\n    return M_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html","title":"gates","text":"<p>Gates</p>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.BosonicGate","title":"<code>BosonicGate</code>","text":"Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicGate(metaclass=ABCMeta):\n    def __init__(\n        self,\n        bcirc: BosonicCircuit,\n        bqubit_indxs: Union[int, Tuple[int, ...]],\n        params: Optional[Dict[str, Any]] = None,\n        ts: Optional[Array] = None,\n        use_unitary: Optional[bool] = False,\n    ):\n        if type(bqubit_indxs) == int:\n            bqubit_indxs = (bqubit_indxs,)\n        bqubit_indxs = cast(Tuple[int, ...], bqubit_indxs)\n\n        self.ts = device_put(ts) if ts is not None else jnp.linspace(0, 1.0, 101)\n        self.params = params if params is not None else {}\n        self.params = device_put_params(self.params)\n\n        self.args: Dict[str, complex] = {}  # used for cython qutip mesolve\n        self.bcirc = bcirc\n        self.bqubit_indxs = bqubit_indxs\n        self.use_unitary = use_unitary\n\n        # pre-load gates\n        # self.H\n        # self.U\n\n    def __str__(self) -&gt; str:\n        return self.label\n\n    @abstractmethod\n    def get_H_func(self, t: float) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        H(t), should be overriden as needed\n\n        Args:\n            t (float): time\n\n        Returns:\n            jqt.Qarray\n        \"\"\"\n\n    @property\n    def H_func(self):\n        \"\"\"\n        Wrapper around get_H_func function.\n        \"\"\"\n        if self.use_unitary:\n            return None\n        return self.get_H_func\n\n    @property\n    def H(self):\n        \"\"\"\n        Allows the storage of H calculations. If use_unitary, then we forgo Hamiltonian simulation.\n\n        Returns:\n            H (list): first element is always a jqt.Qarray or 0\n            other elements are lists of the form [jqt.Qarray, str]\n            E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n            [0, [sigmax, \"cos(t)\"]]\n            [sigmaz]\n            [0]\n        \"\"\"\n        if self.use_unitary:\n            return None\n\n        return self.get_H()\n\n    @property\n    def H_qt(self):\n        if self.use_unitary:\n            return None\n\n        H = self.H\n        if H is None:\n            return None\n        H_qt = [\n            0 if isinstance(H[0], Number) and H[0] == 0 else self.bcirc.jqt2qt(H[0])\n        ]\n        for i in range(1, len(H)):\n            H_qt.append([self.bcirc.jqt2qt(H[i][0]), H[i][1]])\n        return H_qt\n\n    @property\n    def U(self):\n        \"\"\"\n        Allows the storage of U calculations.\n        \"\"\"\n        return self.get_U()\n\n    @property\n    def U_qt(self):\n        return self.bcirc.jqt2qt(self.U)\n\n    @property\n    @abstractmethod\n    def label(self) -&gt; str:\n        \"\"\"\n        Label of gate, used for drawing circuit.\n        E.g. \"X\"\n        \"\"\"\n\n    @abstractmethod\n    def get_H(self) -&gt; Optional[List]:\n        \"\"\"QuTiP cython-backend compatible Hamiltonian list.\n\n        Returns:\n            List of hamiltonians, used for simulation.\n                E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n        \"\"\"\n\n    def _get_U_from_H(self) -&gt; Optional[jqt.Qarray]:\n        H = self.H\n        if type(H) is list and len(H) == 1:\n            H0 = H[0]\n            if isinstance(H0, jqt.Qarray):\n                return jqt.expm(1.0j * H0)\n        return None\n\n    def get_U(self) -&gt; jqt.Qarray:\n        U = self._get_U_from_H()\n        if U is not None:\n            return U\n        raise NotImplementedError(\"Unitary gate has not been implemented.\")\n\n    def extend_gate(self, Ms: List[jqt.Qarray]):\n        \"\"\"\n        This can be used to extend a unitary gate or a hamiltonian.\n        \"\"\"\n        assert len(Ms) == len(self.bqubit_indxs), ValueError(\n            \"The number of qubit indices does not match those expected by this gate.\"\n        )\n        Ms_dict = {}\n        for i, M in enumerate(Ms):\n            Ms_dict[self.bqubit_indxs[i]] = M\n        M_tot = extend_op_to_circ(Ms_dict, self.bcirc)\n        return M_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.BosonicGate.H","title":"<code>H</code>  <code>property</code>","text":"<p>Allows the storage of H calculations. If use_unitary, then we forgo Hamiltonian simulation.</p> <p>Returns:</p> Name Type Description <code>H</code> <code>list</code> <p>first element is always a jqt.Qarray or 0</p> <p>other elements are lists of the form [jqt.Qarray, str]</p> <p>E.g. [sigmaz, [sigmax, \"cos(t)\"]]</p> <p>[0, [sigmax, \"cos(t)\"]]</p> <p>[sigmaz]</p> <p>[0]</p>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.BosonicGate.H_func","title":"<code>H_func</code>  <code>property</code>","text":"<p>Wrapper around get_H_func function.</p>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.BosonicGate.U","title":"<code>U</code>  <code>property</code>","text":"<p>Allows the storage of U calculations.</p>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.BosonicGate.label","title":"<code>label: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Label of gate, used for drawing circuit. E.g. \"X\"</p>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.BosonicGate.extend_gate","title":"<code>extend_gate(Ms)</code>","text":"<p>This can be used to extend a unitary gate or a hamiltonian.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def extend_gate(self, Ms: List[jqt.Qarray]):\n    \"\"\"\n    This can be used to extend a unitary gate or a hamiltonian.\n    \"\"\"\n    assert len(Ms) == len(self.bqubit_indxs), ValueError(\n        \"The number of qubit indices does not match those expected by this gate.\"\n    )\n    Ms_dict = {}\n    for i, M in enumerate(Ms):\n        Ms_dict[self.bqubit_indxs[i]] = M\n    M_tot = extend_op_to_circ(Ms_dict, self.bcirc)\n    return M_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.BosonicGate.get_H","title":"<code>get_H()</code>  <code>abstractmethod</code>","text":"<p>QuTiP cython-backend compatible Hamiltonian list.</p> <p>Returns:</p> Type Description <code>Optional[List]</code> <p>List of hamiltonians, used for simulation. E.g. [sigmaz, [sigmax, \"cos(t)\"]]</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>@abstractmethod\ndef get_H(self) -&gt; Optional[List]:\n    \"\"\"QuTiP cython-backend compatible Hamiltonian list.\n\n    Returns:\n        List of hamiltonians, used for simulation.\n            E.g. [sigmaz, [sigmax, \"cos(t)\"]]\n    \"\"\"\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.BosonicGate.get_H_func","title":"<code>get_H_func(t)</code>  <code>abstractmethod</code>","text":"<p>H(t), should be overriden as needed</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time</p> required <p>Returns:</p> Type Description <code>Optional[Qarray]</code> <p>jqt.Qarray</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>@abstractmethod\ndef get_H_func(self, t: float) -&gt; Optional[jqt.Qarray]:\n    \"\"\"\n    H(t), should be overriden as needed\n\n    Args:\n        t (float): time\n\n    Returns:\n        jqt.Qarray\n    \"\"\"\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.CDGate","title":"<code>CDGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going from t=0 to t=1 to get correct \u03b2.</p>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.CDGate--todo-maybe-add-rate-scale-factor-g-so-that-t-runs-from-0-to-1g","title":"TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g","text":"Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>class CDGate(BosonicGate):\n    \"\"\"\n    Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going\n    from t=0 to t=1 to get correct \u03b2.\n    # TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g\n    \"\"\"\n\n    label = \"CD\"\n\n    def get_H(self) -&gt; List:\n\n        N = self.bcirc.breg[self.bqubit_indxs[0]].params[\"N\"]\n        N2 = self.bcirc.breg[self.bqubit_indxs[1]].params[\"N\"]\n        assert N2 == 2, ValueError(\n            \"Please use a two level system for your second qubit.\"\n        )\n        beta = self.params[\"beta\"]\n        a = jqt.destroy(N)\n        H_tot = self.extend_gate(\n            [\n                1.0j * (beta * jqt.dag(a) - jnp.conj(beta) * a) / jnp.sqrt(2),\n                jqt.sigmaz() / 2,\n            ]\n        )\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        N = self.bcirc.breg[self.bqubit_indxs[0]].params[\"N\"]\n        N2 = self.bcirc.breg[self.bqubit_indxs[1]].params[\"N\"]\n        assert N2 == 2, ValueError(\n            \"Please use a two level system for your second qubit.\"\n        )\n        beta = self.params[\"beta\"]\n        a = jqt.destroy(N)\n        Hs = [\n            -1.0j * (beta * jqt.dag(a) - jnp.conj(beta) * a) / jnp.sqrt(2),\n            jqt.sigmaz() / 2,\n        ]\n        H_tot = self.extend_gate(Hs)\n        U_tot = jqt.expm(1.0j * H_tot)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.GKPCHGate","title":"<code>GKPCHGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going from t=0 to t=1 to get correct \u03b2.</p>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.GKPCHGate--todo-maybe-add-rate-scale-factor-g-so-that-t-runs-from-0-to-1g","title":"TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g","text":"Source code in <code>bosonic/circuit/gates/cavity_cavity.py</code> <pre><code>class GKPCHGate(BosonicGate):\n    \"\"\"\n    Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going\n    from t=0 to t=1 to get correct \u03b2.\n    # TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g\n    \"\"\"\n\n    label = \"GKP CH\"\n\n    def get_H(self) -&gt; List:\n\n        q0 = self.bcirc.breg[self.bqubit_indxs[0]]\n        q1 = self.bcirc.breg[self.bqubit_indxs[1]]\n\n        a = q0.common_gates[\"a\"]\n        a_dag = q0.common_gates[\"a_dag\"]\n\n        b = q1.common_gates[\"a\"]\n        b_dag = q1.common_gates[\"a_dag\"]\n\n        chi = self.params[\"chi\"]\n\n        H_tot = self.extend_gate(\n            [\n                chi * (a_dag + a),\n                (b_dag @ b),\n            ]\n        )\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        q0 = self.bcirc.breg[self.bqubit_indxs[0]]\n        q1 = self.bcirc.breg[self.bqubit_indxs[1]]\n\n        a = q0.common_gates[\"a\"]\n        a_dag = q0.common_gates[\"a_dag\"]\n\n        b = q1.common_gates[\"a\"]\n        b_dag = q1.common_gates[\"a_dag\"]\n\n        angle = jnp.pi/2\n\n        H_tot = self.extend_gate(\n            [\n                angle * (a_dag + a),\n                (b_dag @ b),\n            ]\n        )\n\n        U_tot = jqt.expm(1.0j * H_tot)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.HGate","title":"<code>HGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>HGate.</p> Source code in <code>bosonic/circuit/gates/qubit.py</code> <pre><code>class HGate(BosonicGate):\n    \"\"\"HGate.\"\"\"\n\n    label = \"H\"\n\n    def get_H(self) -&gt; Optional[List]:\n        # TODO: implement this\n        return [0]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        raise NotImplementedError(\"No Hamiltonian for HGate.\")\n\n    def get_U(self) -&gt; jqt.Qarray:\n        Us = [jqt.hadamard()]\n        U_tot = self.extend_gate(Us)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.QubitRotationGate","title":"<code>QubitRotationGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Qubit Rotation Gate R_a(\u03b8) about an axis a = [ax, ay, az] of the Bloch spheres. If no axis is provided, defaults to to R_x(\u03b8) about x-axis.</p> Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>class QubitRotationGate(BosonicGate):\n    \"\"\"\n    Qubit Rotation Gate R_a(\u03b8) about an axis a = [ax, ay, az] of the Bloch\n    spheres. If no axis is provided, defaults to to R_x(\u03b8) about x-axis.\n    \"\"\"\n\n    label = \"Qubit Rotation\"\n\n    def get_sigma_tot(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Helper function that returns (a\u2022\u03c3) = ax*\u03c3x + ay*\u03c3y + az*\u03c3z given\n        an input Bloch vector a. If none is provided, default to \u03c3x.\n        \"\"\"\n\n        if \"rot_axis\" in self.params.keys():\n            a = jnp.array(self.params[\"rot_axis\"])\n            norm = jnp.linalg.norm(a)\n\n            # if a.size != 3 or norm == 0.0:\n            #     raise ValueError(\n            #         \"Please use a nonzero Bloch vector of the form a = [ax, ay, az] \u2260 [0,0,0].\"\n            #     )\n\n            a = (1 / norm) * a\n            sigma_tot = a[0] * jqt.sigmax() + a[1] * jqt.sigmay() + a[2] * jqt.sigmaz()\n\n        else:\n            sigma_tot = jqt.sigmax()\n\n        return sigma_tot\n\n    def get_H(self) -&gt; List:\n\n        omega = self.params[\"omega\"]\n        sigma_tot = self.get_sigma_tot()\n\n        H_tot = self.extend_gate([sigma_tot * omega / 2])\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        theta = self.params[\"theta\"]\n        sigma_tot = self.get_sigma_tot()\n\n        H_tot = self.extend_gate([sigma_tot * theta / 2])\n\n        return jqt.expm(-1.0j * H_tot)\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/index.html#bosonic.circuit.gates.QubitRotationGate.get_sigma_tot","title":"<code>get_sigma_tot()</code>","text":"<p>Helper function that returns (a\u2022\u03c3) = ax\u03c3x + ay\u03c3y + az*\u03c3z given an input Bloch vector a. If none is provided, default to \u03c3x.</p> Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>def get_sigma_tot(self) -&gt; jqt.Qarray:\n    \"\"\"\n    Helper function that returns (a\u2022\u03c3) = ax*\u03c3x + ay*\u03c3y + az*\u03c3z given\n    an input Bloch vector a. If none is provided, default to \u03c3x.\n    \"\"\"\n\n    if \"rot_axis\" in self.params.keys():\n        a = jnp.array(self.params[\"rot_axis\"])\n        norm = jnp.linalg.norm(a)\n\n        # if a.size != 3 or norm == 0.0:\n        #     raise ValueError(\n        #         \"Please use a nonzero Bloch vector of the form a = [ax, ay, az] \u2260 [0,0,0].\"\n        #     )\n\n        a = (1 / norm) * a\n        sigma_tot = a[0] * jqt.sigmax() + a[1] * jqt.sigmay() + a[2] * jqt.sigmaz()\n\n    else:\n        sigma_tot = jqt.sigmax()\n\n    return sigma_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/cavity.html","title":"cavity","text":"<p>Common Gates</p>"},{"location":"reference/bosonic/circuit/gates/cavity_cavity.html","title":"cavity_cavity","text":"<p>Gates specific to cavity qubit system.</p>"},{"location":"reference/bosonic/circuit/gates/cavity_cavity.html#bosonic.circuit.gates.cavity_cavity.GKPCHGate","title":"<code>GKPCHGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going from t=0 to t=1 to get correct \u03b2.</p>"},{"location":"reference/bosonic/circuit/gates/cavity_cavity.html#bosonic.circuit.gates.cavity_cavity.GKPCHGate--todo-maybe-add-rate-scale-factor-g-so-that-t-runs-from-0-to-1g","title":"TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g","text":"Source code in <code>bosonic/circuit/gates/cavity_cavity.py</code> <pre><code>class GKPCHGate(BosonicGate):\n    \"\"\"\n    Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going\n    from t=0 to t=1 to get correct \u03b2.\n    # TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g\n    \"\"\"\n\n    label = \"GKP CH\"\n\n    def get_H(self) -&gt; List:\n\n        q0 = self.bcirc.breg[self.bqubit_indxs[0]]\n        q1 = self.bcirc.breg[self.bqubit_indxs[1]]\n\n        a = q0.common_gates[\"a\"]\n        a_dag = q0.common_gates[\"a_dag\"]\n\n        b = q1.common_gates[\"a\"]\n        b_dag = q1.common_gates[\"a_dag\"]\n\n        chi = self.params[\"chi\"]\n\n        H_tot = self.extend_gate(\n            [\n                chi * (a_dag + a),\n                (b_dag @ b),\n            ]\n        )\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        q0 = self.bcirc.breg[self.bqubit_indxs[0]]\n        q1 = self.bcirc.breg[self.bqubit_indxs[1]]\n\n        a = q0.common_gates[\"a\"]\n        a_dag = q0.common_gates[\"a_dag\"]\n\n        b = q1.common_gates[\"a\"]\n        b_dag = q1.common_gates[\"a_dag\"]\n\n        angle = jnp.pi/2\n\n        H_tot = self.extend_gate(\n            [\n                angle * (a_dag + a),\n                (b_dag @ b),\n            ]\n        )\n\n        U_tot = jqt.expm(1.0j * H_tot)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/cavity_qubit.html","title":"cavity_qubit","text":"<p>Gates specific to cavity qubit system.</p>"},{"location":"reference/bosonic/circuit/gates/cavity_qubit.html#bosonic.circuit.gates.cavity_qubit.CDGate","title":"<code>CDGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going from t=0 to t=1 to get correct \u03b2.</p>"},{"location":"reference/bosonic/circuit/gates/cavity_qubit.html#bosonic.circuit.gates.cavity_qubit.CDGate--todo-maybe-add-rate-scale-factor-g-so-that-t-runs-from-0-to-1g","title":"TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g","text":"Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>class CDGate(BosonicGate):\n    \"\"\"\n    Conditional Displacement Gate CD(\u03b2). Needs to be run with a ts array going\n    from t=0 to t=1 to get correct \u03b2.\n    # TODO: Maybe add rate scale factor g, so that t runs from 0 to 1/g\n    \"\"\"\n\n    label = \"CD\"\n\n    def get_H(self) -&gt; List:\n\n        N = self.bcirc.breg[self.bqubit_indxs[0]].params[\"N\"]\n        N2 = self.bcirc.breg[self.bqubit_indxs[1]].params[\"N\"]\n        assert N2 == 2, ValueError(\n            \"Please use a two level system for your second qubit.\"\n        )\n        beta = self.params[\"beta\"]\n        a = jqt.destroy(N)\n        H_tot = self.extend_gate(\n            [\n                1.0j * (beta * jqt.dag(a) - jnp.conj(beta) * a) / jnp.sqrt(2),\n                jqt.sigmaz() / 2,\n            ]\n        )\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        N = self.bcirc.breg[self.bqubit_indxs[0]].params[\"N\"]\n        N2 = self.bcirc.breg[self.bqubit_indxs[1]].params[\"N\"]\n        assert N2 == 2, ValueError(\n            \"Please use a two level system for your second qubit.\"\n        )\n        beta = self.params[\"beta\"]\n        a = jqt.destroy(N)\n        Hs = [\n            -1.0j * (beta * jqt.dag(a) - jnp.conj(beta) * a) / jnp.sqrt(2),\n            jqt.sigmaz() / 2,\n        ]\n        H_tot = self.extend_gate(Hs)\n        U_tot = jqt.expm(1.0j * H_tot)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/cavity_qubit.html#bosonic.circuit.gates.cavity_qubit.QubitRotationGate","title":"<code>QubitRotationGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>Qubit Rotation Gate R_a(\u03b8) about an axis a = [ax, ay, az] of the Bloch spheres. If no axis is provided, defaults to to R_x(\u03b8) about x-axis.</p> Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>class QubitRotationGate(BosonicGate):\n    \"\"\"\n    Qubit Rotation Gate R_a(\u03b8) about an axis a = [ax, ay, az] of the Bloch\n    spheres. If no axis is provided, defaults to to R_x(\u03b8) about x-axis.\n    \"\"\"\n\n    label = \"Qubit Rotation\"\n\n    def get_sigma_tot(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Helper function that returns (a\u2022\u03c3) = ax*\u03c3x + ay*\u03c3y + az*\u03c3z given\n        an input Bloch vector a. If none is provided, default to \u03c3x.\n        \"\"\"\n\n        if \"rot_axis\" in self.params.keys():\n            a = jnp.array(self.params[\"rot_axis\"])\n            norm = jnp.linalg.norm(a)\n\n            # if a.size != 3 or norm == 0.0:\n            #     raise ValueError(\n            #         \"Please use a nonzero Bloch vector of the form a = [ax, ay, az] \u2260 [0,0,0].\"\n            #     )\n\n            a = (1 / norm) * a\n            sigma_tot = a[0] * jqt.sigmax() + a[1] * jqt.sigmay() + a[2] * jqt.sigmaz()\n\n        else:\n            sigma_tot = jqt.sigmax()\n\n        return sigma_tot\n\n    def get_H(self) -&gt; List:\n\n        omega = self.params[\"omega\"]\n        sigma_tot = self.get_sigma_tot()\n\n        H_tot = self.extend_gate([sigma_tot * omega / 2])\n\n        return [H_tot]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        return self.H[0]\n\n    def get_U(self) -&gt; jqt.Qarray:\n        theta = self.params[\"theta\"]\n        sigma_tot = self.get_sigma_tot()\n\n        H_tot = self.extend_gate([sigma_tot * theta / 2])\n\n        return jqt.expm(-1.0j * H_tot)\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/cavity_qubit.html#bosonic.circuit.gates.cavity_qubit.QubitRotationGate.get_sigma_tot","title":"<code>get_sigma_tot()</code>","text":"<p>Helper function that returns (a\u2022\u03c3) = ax\u03c3x + ay\u03c3y + az*\u03c3z given an input Bloch vector a. If none is provided, default to \u03c3x.</p> Source code in <code>bosonic/circuit/gates/cavity_qubit.py</code> <pre><code>def get_sigma_tot(self) -&gt; jqt.Qarray:\n    \"\"\"\n    Helper function that returns (a\u2022\u03c3) = ax*\u03c3x + ay*\u03c3y + az*\u03c3z given\n    an input Bloch vector a. If none is provided, default to \u03c3x.\n    \"\"\"\n\n    if \"rot_axis\" in self.params.keys():\n        a = jnp.array(self.params[\"rot_axis\"])\n        norm = jnp.linalg.norm(a)\n\n        # if a.size != 3 or norm == 0.0:\n        #     raise ValueError(\n        #         \"Please use a nonzero Bloch vector of the form a = [ax, ay, az] \u2260 [0,0,0].\"\n        #     )\n\n        a = (1 / norm) * a\n        sigma_tot = a[0] * jqt.sigmax() + a[1] * jqt.sigmay() + a[2] * jqt.sigmaz()\n\n    else:\n        sigma_tot = jqt.sigmax()\n\n    return sigma_tot\n</code></pre>"},{"location":"reference/bosonic/circuit/gates/qubit.html","title":"qubit","text":"<p>Fock Qubit gates.</p>"},{"location":"reference/bosonic/circuit/gates/qubit.html#bosonic.circuit.gates.qubit.HGate","title":"<code>HGate</code>","text":"<p>               Bases: <code>BosonicGate</code></p> <p>HGate.</p> Source code in <code>bosonic/circuit/gates/qubit.py</code> <pre><code>class HGate(BosonicGate):\n    \"\"\"HGate.\"\"\"\n\n    label = \"H\"\n\n    def get_H(self) -&gt; Optional[List]:\n        # TODO: implement this\n        return [0]\n\n    def get_H_func(self, t: float) -&gt; jqt.Qarray:\n        raise NotImplementedError(\"No Hamiltonian for HGate.\")\n\n    def get_U(self) -&gt; jqt.Qarray:\n        Us = [jqt.hadamard()]\n        U_tot = self.extend_gate(Us)\n        return U_tot\n</code></pre>"},{"location":"reference/bosonic/codes/index.html","title":"codes","text":"<p>Bosonic Code Qubits</p>"},{"location":"reference/bosonic/codes/base.html","title":"base","text":"<p>Base Bosonic Qubit Class</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit","title":"<code>BosonicQubit</code>","text":"<p>Base class for Bosonic Qubits.</p> Source code in <code>bosonic/codes/base.py</code> <pre><code>class BosonicQubit(metaclass=ABCMeta):\n    \"\"\"\n    Base class for Bosonic Qubits.\n    \"\"\"\n    name = \"bqubit\"\n\n    @property\n    def _non_device_params(self):\n        \"\"\"\n        Can be overriden in child classes.\n        \"\"\"\n        return [\"N\"]\n\n    def __init__(self, params: Optional[Dict[str, float]] = None, name: str = None):\n        if name is not None:\n            self.name = name\n\n        self.params = params if params else {}\n        self._params_validation()\n\n        self.params = device_put_params(self.params, self._non_device_params)\n\n        self.common_gates: Dict[str, jqt.Qarray] = {}\n        self._gen_common_gates()\n\n        self.wigner_pts = jnp.linspace(-4.5, 4.5, 61)\n\n        self.basis = self._get_basis_states()\n\n        for basis_state in [\"+x\", \"-x\", \"+y\", \"-y\", \"+z\", \"-z\"]:\n            assert (\n                basis_state in self.basis\n            ), f\"Please set the {basis_state} basis state.\"\n\n    def _params_validation(self):\n        \"\"\"\n        Override this method to add additional validation to params.\n\n        E.g.\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n        \"\"\"\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n\n    def _gen_common_gates(self):\n        \"\"\"\n        Override this method to add additional common gates.\n\n        E.g.\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n        \"\"\"\n        N = self.params[\"N\"]\n        self.common_gates[\"a_dag\"] = jqt.create(N)\n        self.common_gates[\"a\"] = jqt.destroy(N)\n\n    @abstractmethod\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Returns:\n            plus_z (jqt.Qarray), minus_z (jqt.Qarray): z basis states\n        \"\"\"\n\n    def _get_basis_states(self) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        plus_z, minus_z = self._get_basis_z()\n        return self._gen_basis_states_from_z(plus_z, minus_z)\n\n    def _gen_basis_states_from_z(\n        self, plus_z: jqt.Qarray, minus_z: jqt.Qarray\n    ) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt; from |+-z&gt;\n        \"\"\"\n        basis: Dict[str, jqt.Qarray] = {}\n        N = self.params[\"N\"]\n\n        # import to make sure that each basis state is a column vec\n        # otherwise, transposing a 1D vector will do nothing\n\n        basis[\"+z\"] = plus_z\n        basis[\"-z\"] = minus_z\n\n        basis[\"+x\"] = jqt.unit(basis[\"+z\"] + basis[\"-z\"])\n        basis[\"-x\"] = jqt.unit(basis[\"+z\"] - basis[\"-z\"])\n        basis[\"+y\"] = jqt.unit(basis[\"+z\"] + 1j * basis[\"-z\"])\n        basis[\"-y\"] = jqt.unit(basis[\"+z\"] - 1j * basis[\"-z\"])\n        return basis\n\n    def jqt2qt(self, state):\n        return jqt.jqt2qt(state)\n\n    # gates\n    # ======================================================\n    # @abstractmethod\n    # def stabilize(self) -&gt; None:\n    #     \"\"\"\n    #     Stabilizing/measuring syndromes.\n    #     \"\"\"\n\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical X unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"x\")\n\n    @property\n    def x_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical X hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Y unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"y\")\n\n    @property\n    def y_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Y hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Z unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"z\")\n\n    @property\n    def z_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Z hamiltonian.\n        \"\"\"\n        return None\n\n\n    @property \n    def h_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Hadamard hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def h_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Hadamard unitary gate.\n        \"\"\"\n        return self.basis[\"+x\"] @ self.basis[\"+z\"].dag() + self.basis[\"-x\"] @ self.basis[\"-z\"].dag()\n\n    def _gen_pauli_U(self, basis_state: str) -&gt; jqt.Qarray:\n        \"\"\"\n        Generates unitary for Pauli X, Y, Z.\n\n        Args:\n            basis_state (str): \"x\", \"y\", \"z\"\n\n        Returns:\n            U (jqt.Qarray): Pauli unitary\n        \"\"\"\n        H = getattr(self, basis_state + \"_H\")\n        if H is not None:\n            return jqt.expm(1.0j * H)\n\n        gate = (\n            self.basis[\"+\" + basis_state] @ self.basis[\"+\" + basis_state].dag()\n            - self.basis[\"-\" + basis_state] @ self.basis[\"-\" + basis_state].dag()\n        )\n\n        return gate\n\n    @property\n    def projector(self):\n        return (\n            self.basis[\"+z\"] @ self.basis[\"+z\"].dag()\n            + self.basis[\"-z\"] @ self.basis[\"-z\"].dag()\n        )\n\n    @property\n    def maximally_mixed_state(self):\n        return (1 / 2.0) * self.projector()\n\n    # Plotting\n    # ======================================================\n    def _prepare_state_plot(self, state):\n        \"\"\"\n        Can be overriden.\n\n        E.g. in the case of cavity x transmon system\n        return qt.ptrace(state, 0)\n        \"\"\"\n        return state\n\n    def plot(self, state, ax=None, qp_type=jqt.WIGNER, **kwargs) -&gt; None:\n        if ax is None:\n            fig, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n        fig = ax.get_figure()\n\n        if qp_type == jqt.WIGNER:\n            vmin = -1\n            vmax = 1\n        elif qp_type == jqt.QFUNC:\n            vmin = 0\n            vmax = 1\n\n        w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n\n        ax.set_title(qp_type.capitalize() + \" Quasi-Probability Dist.\")\n        ticks = np.linspace(vmin, vmax, 5)\n        fig.colorbar(w_plt, ax=ax, ticks=ticks)\n        ax.set_xlabel(r\"Re$(\\alpha)$\")\n        ax.set_ylabel(r\"Im$(\\alpha)$\")\n        fig.tight_layout()\n\n        plt.show()\n\n    def _plot_single(self, state, ax=None, contour=True, qp_type=jqt.WIGNER):\n        \"\"\"\n        Assumes state has same dims as initial_state.\n        \"\"\"\n        state = self.jqt2qt(state)\n\n        if ax is None:\n            _, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n\n        return jqt.plot_qp(\n            state, self.wigner_pts, ax=ax, contour=contour, qp_type=qp_type\n        )\n\n    def plot_code_states(self, qp_type: str = jqt.WIGNER, **kwargs):\n        \"\"\"\n        Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.\n\n        Args:\n            qp_type (str): \n                WIGNER or QFUNC\n\n        Return:\n            axs: Axes \n        \"\"\"\n        fig, axs = plt.subplots(2, 3, figsize=(9, 6), dpi=200)\n        if qp_type == jqt.WIGNER:\n            cbar_title = r\"$\\frac{\\pi}{2} W(\\alpha)$\"\n            vmin = -1\n            vmax = 1\n        elif qp_type == jqt.QFUNC:\n            cbar_title = r\"$\\pi Q(\\alpha)$\"\n            vmin = 0\n            vmax = 1\n\n        for i, label in enumerate([\"+z\", \"+x\", \"+y\", \"-z\", \"-x\", \"-y\"]):\n            state = self._prepare_state_plot(self.basis[label])\n            pos = (i // 3, i % 3)\n            ax = axs[pos]\n            w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n            ax.set_title(f\"|{label}\" + r\"$\\rangle$\")\n            ax.set_xlabel(r\"Re[$\\alpha$]\")\n            ax.set_ylabel(r\"Im[$\\alpha$]\")\n\n        fig.suptitle(self.name)\n        fig.tight_layout()\n        fig.subplots_adjust(right=0.8, hspace=0.2, wspace=0.2)\n        fig.align_xlabels(axs)\n        fig.align_ylabels(axs)\n        cbar_ax = fig.add_axes([0.85 + 0.2, 0.15, 0.05, 0.7])\n\n        ticks = np.linspace(vmin, vmax, 5)\n        fig.colorbar(w_plt, cax=cbar_ax, ticks=ticks)\n\n        cbar_ax.set_title(cbar_title, pad=20)\n        fig.tight_layout()\n        plt.show()\n</code></pre>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.h_H","title":"<code>h_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Hadamard hamiltonian.</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.h_U","title":"<code>h_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Hadamard unitary gate.</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.x_H","title":"<code>x_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical X hamiltonian.</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.x_U","title":"<code>x_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical X unitary gate.</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.y_H","title":"<code>y_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Y hamiltonian.</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.y_U","title":"<code>y_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Y unitary gate.</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.z_H","title":"<code>z_H: Optional[jqt.Qarray]</code>  <code>property</code>","text":"<p>Logical Z hamiltonian.</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.z_U","title":"<code>z_U: jqt.Qarray</code>  <code>property</code>","text":"<p>Logical Z unitary gate.</p>"},{"location":"reference/bosonic/codes/base.html#bosonic.codes.base.BosonicQubit.plot_code_states","title":"<code>plot_code_states(qp_type=jqt.WIGNER, **kwargs)</code>","text":"<p>Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.</p> <p>Parameters:</p> Name Type Description Default <code>qp_type</code> <code>str</code> <p>WIGNER or QFUNC</p> <code>WIGNER</code> Return <p>axs: Axes</p> Source code in <code>bosonic/codes/base.py</code> <pre><code>def plot_code_states(self, qp_type: str = jqt.WIGNER, **kwargs):\n    \"\"\"\n    Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.\n\n    Args:\n        qp_type (str): \n            WIGNER or QFUNC\n\n    Return:\n        axs: Axes \n    \"\"\"\n    fig, axs = plt.subplots(2, 3, figsize=(9, 6), dpi=200)\n    if qp_type == jqt.WIGNER:\n        cbar_title = r\"$\\frac{\\pi}{2} W(\\alpha)$\"\n        vmin = -1\n        vmax = 1\n    elif qp_type == jqt.QFUNC:\n        cbar_title = r\"$\\pi Q(\\alpha)$\"\n        vmin = 0\n        vmax = 1\n\n    for i, label in enumerate([\"+z\", \"+x\", \"+y\", \"-z\", \"-x\", \"-y\"]):\n        state = self._prepare_state_plot(self.basis[label])\n        pos = (i // 3, i % 3)\n        ax = axs[pos]\n        w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n        ax.set_title(f\"|{label}\" + r\"$\\rangle$\")\n        ax.set_xlabel(r\"Re[$\\alpha$]\")\n        ax.set_ylabel(r\"Im[$\\alpha$]\")\n\n    fig.suptitle(self.name)\n    fig.tight_layout()\n    fig.subplots_adjust(right=0.8, hspace=0.2, wspace=0.2)\n    fig.align_xlabels(axs)\n    fig.align_ylabels(axs)\n    cbar_ax = fig.add_axes([0.85 + 0.2, 0.15, 0.05, 0.7])\n\n    ticks = np.linspace(vmin, vmax, 5)\n    fig.colorbar(w_plt, cax=cbar_ax, ticks=ticks)\n\n    cbar_ax.set_title(cbar_title, pad=20)\n    fig.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"reference/bosonic/codes/binomial.html","title":"binomial","text":"<p>Cat Code Qubit</p>"},{"location":"reference/bosonic/codes/binomial.html#bosonic.codes.binomial.BinomialQubit","title":"<code>BinomialQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>Cat Qubit Class.</p> Source code in <code>bosonic/codes/binomial.py</code> <pre><code>class BinomialQubit(BosonicQubit):\n    \"\"\"\n    Cat Qubit Class.\n    \"\"\"\n    name = \"binomial\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n        # notation https://arxiv.org/pdf/2010.08699.pdf\n        if \"L\" not in self.params:\n            self.params[\"L\"] = 1\n        if \"G\" not in self.params:\n            self.params[\"G\"] = 0\n        if \"D\" not in self.params:\n            self.params[\"D\"] = 0\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = self.params[\"N\"]\n\n        L = self.params[\"L\"]\n        G = self.params[\"G\"]\n        D = self.params[\"D\"]\n\n        S = L + G\n\n        M = jnp.max(jnp.array([L, G, 2 * D]))\n\n        def plus_z_gen(p):\n            C = comb(M + 1, p)\n            return jnp.sqrt(C) * jqt.basis(N, p * (S + 1)).data\n\n        plus_z = jnp.sum(vmap(plus_z_gen)(jnp.arange(0, M + 2, 2)), axis=0)\n        plus_z = jqt.unit(jqt.Qarray.create(plus_z))\n\n        def minus_z_gen(p):\n            C = comb(M + 1, p)\n            return jnp.sqrt(C) * jqt.basis(N, p * (S + 1)).data\n\n        minus_z = jnp.sum(vmap(minus_z_gen)(jnp.arange(1, M + 2, 2)), axis=0)\n        minus_z = jqt.unit(jqt.Qarray.create(minus_z))\n\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/bosonic/codes/cat.html","title":"cat","text":"<p>Cat Code Qubit</p>"},{"location":"reference/bosonic/codes/cat.html#bosonic.codes.cat.CatQubit","title":"<code>CatQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>Cat Qubit Class.</p> Source code in <code>bosonic/codes/cat.py</code> <pre><code>class CatQubit(BosonicQubit):\n    \"\"\"\n    Cat Qubit Class.\n    \"\"\"\n    name = \"cat\"\n\n    @property\n    def _non_device_params(self):\n        param_list = super()._non_device_params\n        param_list.append(\"alpha\")\n        return param_list\n\n    def _params_validation(self):\n        super()._params_validation()\n        if \"alpha\" not in self.params:\n            self.params[\"alpha\"] = 2\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = self.params[\"N\"]\n        a = self.params[\"alpha\"]\n        plus_z = jqt.unit(jqt.coherent(N, a) + jqt.coherent(N, -1.0 * a))\n        minus_z = jqt.unit(jqt.coherent(N, 1.0j * a) + jqt.coherent(N, -1.0j * a))\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/bosonic/codes/gkp.html","title":"gkp","text":"<p>Cat Code Qubit</p>"},{"location":"reference/bosonic/codes/gkp.html#bosonic.codes.gkp.GKPQubit","title":"<code>GKPQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>GKP Qubit Class.</p> Source code in <code>bosonic/codes/gkp.py</code> <pre><code>class GKPQubit(BosonicQubit):\n    \"\"\"\n    GKP Qubit Class.\n    \"\"\"\n    name = \"gkp\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n        if \"delta\" not in self.params:\n            self.params[\"delta\"] = 0.25\n        self.params[\"l\"] = 2.0 * jnp.sqrt(jnp.pi)\n        s_delta = jnp.sinh(self.params[\"delta\"] ** 2)\n        self.params[\"epsilon\"] = s_delta * self.params[\"l\"]\n\n    def _gen_common_gates(self) -&gt; None:\n        \"\"\"\n        Overriding this method to add additional common gates.\n        \"\"\"\n        super()._gen_common_gates()\n\n        # phase space\n        self.common_gates[\"x\"] = (\n            self.common_gates[\"a_dag\"] + self.common_gates[\"a\"]\n        ) / jnp.sqrt(2.0)\n        self.common_gates[\"p\"] = (\n            1.0j * (self.common_gates[\"a_dag\"] - self.common_gates[\"a\"]) / jnp.sqrt(2.0)\n        )\n\n        # finite energy\n        self.common_gates[\"E\"] = jqt.expm(\n            -self.params[\"delta\"] ** 2\n            * self.common_gates[\"a_dag\"]\n            @ self.common_gates[\"a\"]\n        )\n        self.common_gates[\"E_inv\"] = jqt.expm(\n            self.params[\"delta\"] ** 2\n            * self.common_gates[\"a_dag\"]\n            @ self.common_gates[\"a\"]\n        )\n\n        # axis\n        x_axis, z_axis = self._get_axis()\n        y_axis = x_axis + z_axis\n\n        # gates\n        X_0 = jqt.expm(1.0j * self.params[\"l\"] / 2.0 * z_axis)\n        Z_0 = jqt.expm(1.0j * self.params[\"l\"] / 2.0 * x_axis)\n        Y_0 = 1.0j * X_0 @ Z_0\n        self.common_gates[\"X\"] = self._make_op_finite_energy(X_0)\n        self.common_gates[\"Z\"] = self._make_op_finite_energy(Z_0)\n        self.common_gates[\"Y\"] = self._make_op_finite_energy(Y_0)\n\n        # symmetric stabilizers and gates\n        self.common_gates[\"Z_s_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] / 2.0 * x_axis\n        )\n        self.common_gates[\"S_x_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * z_axis\n        )\n        self.common_gates[\"S_z_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * x_axis\n        )\n        self.common_gates[\"S_y_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * y_axis\n        )\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;.\n        step 1: use ideal GKP stabilizers to find ideal GKP |+z&gt; state\n        step 2: make ideal eigenvector finite energy\n            We want the groundstate of H = E H_0 E\u207b\u00b9.\n            So, we can begin by find the groundstate of H_0 -&gt; |\u03bb\u2080\u27e9\n            Then, we know that E|\u03bb\u2080\u27e9 = |\u03bb\u27e9 is the groundstate of H.\n            pf. H|\u03bb\u27e9 = (E H_0 E\u207b\u00b9)(E|\u03bb\u2080\u27e9) = E H_0 |\u03bb\u2080\u27e9 = \u03bb\u2080 (E|\u03bb\u2080\u27e9) = \u03bb\u2080|\u03bb\u27e9\n\n        TODO (if necessary):\n            Alternatively, we could construct a hamiltonian using\n            finite energy stabilizers S_x, S_y, S_z, Z_s. However,\n            this would make H = - S_x - S_y - S_z - Z_s non-hermitian.\n            Currently, JAX does not support derivatives of jnp.linalg.eig,\n            while it does support derivatives of jnp.linalg.eigh.\n            Discussion: https://github.com/google/jax/issues/2748\n        \"\"\"\n\n        # step 1: use ideal GKP stabilizers to find ideal GKP |+z&gt; state\n        H_0 = (\n            -self.common_gates[\"S_x_0\"]\n            - self.common_gates[\"S_y_0\"]\n            - self.common_gates[\"S_z_0\"]\n            - self.common_gates[\"Z_s_0\"]  # bosonic |+z&gt; state\n        )\n\n        _, vecs = jnp.linalg.eigh(H_0.data)\n        gstate_ideal = jqt.Qarray.create(vecs[:, 0])\n\n        # step 2: make ideal eigenvector finite energy\n        gstate = self.common_gates[\"E\"] @ gstate_ideal\n\n        N = self.params[\"N\"]\n        plus_z = jqt.unit(gstate)\n        minus_z = self.common_gates[\"X\"] @ plus_z\n        return plus_z, minus_z\n\n    # utils\n    # ======================================================\n    def _get_axis(self):\n        x_axis = self.common_gates[\"x\"]\n        z_axis = -self.common_gates[\"p\"]\n        return x_axis, z_axis\n\n    def _make_op_finite_energy(self, op):\n        return self.common_gates[\"E\"] @ op @ self.common_gates[\"E_inv\"]\n\n    def _symmetrized_expm(self, op):\n        return (jqt.expm(op) + jqt.expm(-1.0 * op)) / 2.0\n\n    # gates\n    # ======================================================\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"X\"]\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"Y\"]\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"Z\"]\n</code></pre>"},{"location":"reference/bosonic/codes/mode.html","title":"mode","text":"<p>Generic Bosonic Mode Class</p>"},{"location":"reference/bosonic/codes/mode.html#bosonic.codes.mode.BosonicMode","title":"<code>BosonicMode</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>FockQubit</p> Source code in <code>bosonic/codes/mode.py</code> <pre><code>class BosonicMode(BosonicQubit):\n    \"\"\"\n    FockQubit\n    \"\"\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = int(self.params[\"N\"])\n        plus_z = jqt.basis(N, 0)\n        minus_z = jqt.basis(N, 1)\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/bosonic/codes/qubit.html","title":"qubit","text":"<p>Qubit</p>"},{"location":"reference/bosonic/codes/qubit.html#bosonic.codes.qubit.Qubit","title":"<code>Qubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>FockQubit</p> Source code in <code>bosonic/codes/qubit.py</code> <pre><code>class Qubit(BosonicQubit):\n    \"\"\"\n    FockQubit\n    \"\"\"\n\n    def _params_validation(self):\n        super()._params_validation()\n        self.params[\"N\"] = 2\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = int(self.params[\"N\"])\n        plus_z = jqt.basis(N, 0)\n        minus_z = jqt.basis(N, 1)\n        return plus_z, minus_z\n\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmax()\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmay()\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmaz()\n\n    def plot(self, state, ax=None, qp_type=\"\", **kwargs) -&gt; None:\n        state = self.jqt2qt(state)\n        with warnings.catch_warnings():\n            # TODO: suppressing deprecation warnings, deal with this\n            warnings.simplefilter(\"ignore\")\n            b = qt.Bloch()\n            b.add_states(state)\n            b.render()\n            b.show()\n            plt.tight_layout()\n            plt.show()\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html","title":"simulator","text":"<p>Simulator Infra</p>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicCircuit","title":"<code>BosonicCircuit</code>","text":"<p>BosonicCircuit allows users to build quantum circuits out of many bosonic qubits.</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>class BosonicCircuit:\n    \"\"\"\n    BosonicCircuit allows users to build quantum circuits out of many bosonic qubits.\n    \"\"\"\n\n    def __init__(self, breg: BosonicRegister):\n        self.breg = breg\n        self.reset_gates()\n\n    def get_dims(self):\n        dims = []\n        for bq in self.breg.bqubits:\n            dims.append(bq.params[\"N\"])\n        dims = jnp.array(dims)\n        dims = jnp.array([dims, jnp.ones_like(dims)])\n        return dims\n\n    @property\n    def dims(self):\n        return self.get_dims()\n\n    @property\n    def dm_dims(self):\n        return jnp.array([self.dims[0], self.dims[0]])\n\n    @property\n    def default_initial_state(self):\n        return self.gen_default_initial_state()\n\n    def gen_default_initial_state(self) -&gt; jqt.Qarray:\n        state = None\n\n        for bq in self.breg.bqubits:\n            state = (\n                bq.basis[\"+z\"] if state is None else jqt.tensor(state, bq.basis[\"+z\"])\n            )\n\n        return cast(jqt.Qarray, state)\n\n    def reset_gates(self) -&gt; None:\n        self.gates: List[BosonicGate] = []\n\n    def reset(self) -&gt; None:\n        self.reset_gates()\n\n    def add(\n        self,\n        gate_type: Type[\"BosonicGate\"],\n        bqubit_indxs: Union[int, Tuple[int, ...]],\n        params: Optional[Dict[str, complex]] = None,\n        ts: Optional[Array] = None,\n        use_unitary: Optional[bool] = False,\n    ):\n        if type(bqubit_indxs) == int:\n            bqubit_indxs = (bqubit_indxs,)\n        bqubit_indxs = cast(Tuple[int, ...], bqubit_indxs)\n\n        num_qubits = len(self.breg)\n        for j in bqubit_indxs:\n            if j &gt;= num_qubits:\n                raise ValueError(\n                    f\"Please choose qubit indices in the range [0,{num_qubits-1}]\"\n                )\n\n        self.gates.append(\n            gate_type(self, bqubit_indxs, params=params, ts=ts, use_unitary=use_unitary)\n        )\n\n    def x(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical X\n        \"\"\"\n        self.gates.append(XGate(self, bqubit_indx))\n\n    def y(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Y\n        \"\"\"\n        self.gates.append(YGate(self, bqubit_indx))\n\n    def z(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Z\n        \"\"\"\n        self.gates.append(ZGate(self, bqubit_indx))\n\n    def h(self, bqubit_indx: int) -&gt; None:\n        \"\"\"\n        Logical Hadamard\n        \"\"\"\n        self.gates.append(HGate(self, bqubit_indx))\n\n    def draw(self):\n        NotImplementedError(\"Not implemented yet!\")\n\n    def jqt2qt(self, state: jqt.Qarray):\n        return jqt.jqt2qt(state)\n\n    def plot(\n        self,\n        bqubit_indx: Optional[int] = None,\n        state: Optional[jqt.Qarray] = None,\n    ):\n        \"\"\"\n        Plot default_initial_state or other state of the bcirc.\n\n        Args:\n            bqubit_indx (int): index of logical qubit in bcirc\n\n        \"\"\"\n        state = state if state is not None else self.default_initial_state\n        state = self.jqt2qt(state)\n\n        if bqubit_indx is not None:\n            self.breg[bqubit_indx].plot(state.ptrace(bqubit_indx))  # type: ignore\n        else:\n            for j in range(len(self.breg)):\n                self.breg[j].plot(state.ptrace(j))  # type: ignore\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicCircuit.h","title":"<code>h(bqubit_indx)</code>","text":"<p>Logical Hadamard</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def h(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Hadamard\n    \"\"\"\n    self.gates.append(HGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicCircuit.plot","title":"<code>plot(bqubit_indx=None, state=None)</code>","text":"<p>Plot default_initial_state or other state of the bcirc.</p> <p>Parameters:</p> Name Type Description Default <code>bqubit_indx</code> <code>int</code> <p>index of logical qubit in bcirc</p> <code>None</code> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def plot(\n    self,\n    bqubit_indx: Optional[int] = None,\n    state: Optional[jqt.Qarray] = None,\n):\n    \"\"\"\n    Plot default_initial_state or other state of the bcirc.\n\n    Args:\n        bqubit_indx (int): index of logical qubit in bcirc\n\n    \"\"\"\n    state = state if state is not None else self.default_initial_state\n    state = self.jqt2qt(state)\n\n    if bqubit_indx is not None:\n        self.breg[bqubit_indx].plot(state.ptrace(bqubit_indx))  # type: ignore\n    else:\n        for j in range(len(self.breg)):\n            self.breg[j].plot(state.ptrace(j))  # type: ignore\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicCircuit.x","title":"<code>x(bqubit_indx)</code>","text":"<p>Logical X</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def x(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical X\n    \"\"\"\n    self.gates.append(XGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicCircuit.y","title":"<code>y(bqubit_indx)</code>","text":"<p>Logical Y</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def y(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Y\n    \"\"\"\n    self.gates.append(YGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicCircuit.z","title":"<code>z(bqubit_indx)</code>","text":"<p>Logical Z</p> Source code in <code>bosonic/circuit/base.py</code> <pre><code>def z(self, bqubit_indx: int) -&gt; None:\n    \"\"\"\n    Logical Z\n    \"\"\"\n    self.gates.append(ZGate(self, bqubit_indx))\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicResults","title":"<code>BosonicResults</code>","text":"<p>BosonicResults class to hold results of simulation.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>class BosonicResults:\n    \"\"\"\n    BosonicResults class to hold results of simulation.\n    \"\"\"\n\n    def __init__(self, results: Optional[List] = None):\n        self.__results = results if results is not None else []\n\n    @property\n    def results(self):\n        \"\"\"\n        self.results is read-only\n        \"\"\"\n        return self.__results\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return str(self.results)\n\n    def __getitem__(self, j: int):\n        return self.results[j]\n\n    def calc_expect(self, op: jqt.Qarray, op_name: str):\n        \"\"\"\n        TODO (if needed):\n        This only works for jax simulations.\n        We may want to extend it to accomodate QuTiP mesolve sims.\n        \"\"\"\n\n        def calc_exp_state(state: Array):\n            return (jnp.conj(state).T @ op.data @ state)[0][0]\n\n        for i in range(len(self.results)):\n            if op_name not in self.results[i]:\n                self.results[i][op_name] = vmap(calc_exp_state)(\n                    jqt.jqts2jnps(self.results[i][\"states\"])\n                )\n\n    def append(self, states):\n        self.__results.append({\"states\": states})\n\n    def plot(self, bcirc: BosonicCircuit, indx: Optional[int] = None):\n        \"\"\"\n        Plots final state.\n        \"\"\"\n        bcirc.plot(indx, state=self.results[-1][\"states\"][-1])\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicResults.results","title":"<code>results</code>  <code>property</code>","text":"<p>self.results is read-only</p>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicResults.calc_expect","title":"<code>calc_expect(op, op_name)</code>","text":"<p>TODO (if needed): This only works for jax simulations. We may want to extend it to accomodate QuTiP mesolve sims.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>def calc_expect(self, op: jqt.Qarray, op_name: str):\n    \"\"\"\n    TODO (if needed):\n    This only works for jax simulations.\n    We may want to extend it to accomodate QuTiP mesolve sims.\n    \"\"\"\n\n    def calc_exp_state(state: Array):\n        return (jnp.conj(state).T @ op.data @ state)[0][0]\n\n    for i in range(len(self.results)):\n        if op_name not in self.results[i]:\n            self.results[i][op_name] = vmap(calc_exp_state)(\n                jqt.jqts2jnps(self.results[i][\"states\"])\n            )\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.BosonicResults.plot","title":"<code>plot(bcirc, indx=None)</code>","text":"<p>Plots final state.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>def plot(self, bcirc: BosonicCircuit, indx: Optional[int] = None):\n    \"\"\"\n    Plots final state.\n    \"\"\"\n    bcirc.plot(indx, state=self.results[-1][\"states\"][-1])\n</code></pre>"},{"location":"reference/bosonic/simulator/index.html#bosonic.simulator.hamiltonian_jax_simulate","title":"<code>hamiltonian_jax_simulate(bcirc, H0, p0=None, default_unitary=True, c_ops=None, results_in=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>H0</code> <code>Qarray</code> <p>base system hamiltonian, please make sure this a jnp.array not a QuTiP Qobj</p> required Source code in <code>bosonic/simulator/base.py</code> <pre><code>def hamiltonian_jax_simulate(\n    bcirc: BosonicCircuit,\n    H0: jqt.Qarray,\n    p0: jqt.Qarray = None,\n    default_unitary=True,\n    c_ops=None,\n    results_in: Optional[BosonicResults] = None,\n):\n    \"\"\"\n\n    Args:\n        H0 (jqt.Qarray):\n            base system hamiltonian,\n            please make sure this a jnp.array not a QuTiP Qobj\n    \"\"\"\n    # p0 is a density matrix, but can also be wavefunction if c_ops=None\n    p = p0 if p0 is not None else bcirc.default_initial_state\n    c_ops = c_ops if c_ops is not None else []\n\n    p = jqt.qt2jqt(p)\n\n    if len(c_ops) &gt; 0 and not p.is_dm():\n        # if simulating with noise and p is a vector,\n        # then turn p into a density matrix\n        p = p.to_dm()\n\n    use_density_matrix = p.is_dm()\n    results = BosonicResults() if results_in is None else results_in\n\n    results.append([p])\n\n    for gate in bcirc.gates:\n        t_list = gate.ts\n        use_hamiltonian = not (gate.H_func is None or gate.H_func(t_list[0]) is None)\n\n        if use_hamiltonian:\n            states = hamiltonian_jax_step(\n                gate.H_func,\n                p,\n                t_list,\n                H0,\n                c_ops=c_ops,\n                use_density_matrix=use_density_matrix,\n            )\n            results.append(states)\n            p = states[-1]\n        elif default_unitary:\n            # H_func is None or returns None, then just use unitary evolution\n            U = jqt.qt2jqt(gate.U)\n            p = unitary_jax_step(p, U, use_density_matrix=use_density_matrix)\n            results.append([p])\n        else:\n            warnings.warn(f\"{gate} Gate was skipped.\", RuntimeWarning, stacklevel=2)\n\n    return results\n</code></pre>"},{"location":"reference/bosonic/simulator/base.html","title":"base","text":"<p>Base simulator class</p>"},{"location":"reference/bosonic/simulator/base.html#bosonic.simulator.base.BosonicResults","title":"<code>BosonicResults</code>","text":"<p>BosonicResults class to hold results of simulation.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>class BosonicResults:\n    \"\"\"\n    BosonicResults class to hold results of simulation.\n    \"\"\"\n\n    def __init__(self, results: Optional[List] = None):\n        self.__results = results if results is not None else []\n\n    @property\n    def results(self):\n        \"\"\"\n        self.results is read-only\n        \"\"\"\n        return self.__results\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return str(self.results)\n\n    def __getitem__(self, j: int):\n        return self.results[j]\n\n    def calc_expect(self, op: jqt.Qarray, op_name: str):\n        \"\"\"\n        TODO (if needed):\n        This only works for jax simulations.\n        We may want to extend it to accomodate QuTiP mesolve sims.\n        \"\"\"\n\n        def calc_exp_state(state: Array):\n            return (jnp.conj(state).T @ op.data @ state)[0][0]\n\n        for i in range(len(self.results)):\n            if op_name not in self.results[i]:\n                self.results[i][op_name] = vmap(calc_exp_state)(\n                    jqt.jqts2jnps(self.results[i][\"states\"])\n                )\n\n    def append(self, states):\n        self.__results.append({\"states\": states})\n\n    def plot(self, bcirc: BosonicCircuit, indx: Optional[int] = None):\n        \"\"\"\n        Plots final state.\n        \"\"\"\n        bcirc.plot(indx, state=self.results[-1][\"states\"][-1])\n</code></pre>"},{"location":"reference/bosonic/simulator/base.html#bosonic.simulator.base.BosonicResults.results","title":"<code>results</code>  <code>property</code>","text":"<p>self.results is read-only</p>"},{"location":"reference/bosonic/simulator/base.html#bosonic.simulator.base.BosonicResults.calc_expect","title":"<code>calc_expect(op, op_name)</code>","text":"<p>TODO (if needed): This only works for jax simulations. We may want to extend it to accomodate QuTiP mesolve sims.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>def calc_expect(self, op: jqt.Qarray, op_name: str):\n    \"\"\"\n    TODO (if needed):\n    This only works for jax simulations.\n    We may want to extend it to accomodate QuTiP mesolve sims.\n    \"\"\"\n\n    def calc_exp_state(state: Array):\n        return (jnp.conj(state).T @ op.data @ state)[0][0]\n\n    for i in range(len(self.results)):\n        if op_name not in self.results[i]:\n            self.results[i][op_name] = vmap(calc_exp_state)(\n                jqt.jqts2jnps(self.results[i][\"states\"])\n            )\n</code></pre>"},{"location":"reference/bosonic/simulator/base.html#bosonic.simulator.base.BosonicResults.plot","title":"<code>plot(bcirc, indx=None)</code>","text":"<p>Plots final state.</p> Source code in <code>bosonic/simulator/base.py</code> <pre><code>def plot(self, bcirc: BosonicCircuit, indx: Optional[int] = None):\n    \"\"\"\n    Plots final state.\n    \"\"\"\n    bcirc.plot(indx, state=self.results[-1][\"states\"][-1])\n</code></pre>"},{"location":"reference/bosonic/simulator/base.html#bosonic.simulator.base.hamiltonian_jax_simulate","title":"<code>hamiltonian_jax_simulate(bcirc, H0, p0=None, default_unitary=True, c_ops=None, results_in=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>H0</code> <code>Qarray</code> <p>base system hamiltonian, please make sure this a jnp.array not a QuTiP Qobj</p> required Source code in <code>bosonic/simulator/base.py</code> <pre><code>def hamiltonian_jax_simulate(\n    bcirc: BosonicCircuit,\n    H0: jqt.Qarray,\n    p0: jqt.Qarray = None,\n    default_unitary=True,\n    c_ops=None,\n    results_in: Optional[BosonicResults] = None,\n):\n    \"\"\"\n\n    Args:\n        H0 (jqt.Qarray):\n            base system hamiltonian,\n            please make sure this a jnp.array not a QuTiP Qobj\n    \"\"\"\n    # p0 is a density matrix, but can also be wavefunction if c_ops=None\n    p = p0 if p0 is not None else bcirc.default_initial_state\n    c_ops = c_ops if c_ops is not None else []\n\n    p = jqt.qt2jqt(p)\n\n    if len(c_ops) &gt; 0 and not p.is_dm():\n        # if simulating with noise and p is a vector,\n        # then turn p into a density matrix\n        p = p.to_dm()\n\n    use_density_matrix = p.is_dm()\n    results = BosonicResults() if results_in is None else results_in\n\n    results.append([p])\n\n    for gate in bcirc.gates:\n        t_list = gate.ts\n        use_hamiltonian = not (gate.H_func is None or gate.H_func(t_list[0]) is None)\n\n        if use_hamiltonian:\n            states = hamiltonian_jax_step(\n                gate.H_func,\n                p,\n                t_list,\n                H0,\n                c_ops=c_ops,\n                use_density_matrix=use_density_matrix,\n            )\n            results.append(states)\n            p = states[-1]\n        elif default_unitary:\n            # H_func is None or returns None, then just use unitary evolution\n            U = jqt.qt2jqt(gate.U)\n            p = unitary_jax_step(p, U, use_density_matrix=use_density_matrix)\n            results.append([p])\n        else:\n            warnings.warn(f\"{gate} Gate was skipped.\", RuntimeWarning, stacklevel=2)\n\n    return results\n</code></pre>"}]}